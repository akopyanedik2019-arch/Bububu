<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D –Æ–ø–∏—Ç–µ—Ä - –ö–æ—Å–º–∏—á–µ—Å–∫–∞—è –∫—Ä–∞—Å–æ—Ç–∞</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000000;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            height: 100vh;
            width: 100vw;
            cursor: grab;
            -webkit-tap-highlight-color: transparent;
        }

        body:active {
            cursor: grabbing;
        }

        #container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000000;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: #ff9a3c;
            font-size: 20px;
            flex-direction: column;
            gap: 20px;
            transition: opacity 1s;
        }

        .loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 154, 60, 0.2);
            border-top: 4px solid #ff9a3c;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* –°–∫—Ä—ã—Ç—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã */
        .hidden-element {
            position: absolute;
            opacity: 0;
            pointer-events: none;
            z-index: -1;
        }

        /* –≠—Ñ—Ñ–µ–∫—Ç –≤–∑—Ä—ã–≤–∞ */
        .explosion-text {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 120px;
            font-weight: 900;
            color: #ff0066;
            text-shadow: 
                0 0 30px #ff0066,
                0 0 60px #ff3366,
                0 0 90px #ff6699,
                0 0 120px #ff99cc;
            z-index: 2000;
            opacity: 0;
            pointer-events: none;
            font-family: 'Impact', 'Arial Black', sans-serif;
            text-align: center;
            line-height: 1.2;
            letter-spacing: 2px;
            transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            filter: blur(0);
        }

        .explosion-text.visible {
            opacity: 1;
            animation: textBoom 2.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }

        @keyframes textBoom {
            0% {
                transform: translate(-50%, -50%) scale(0.1) rotate(-180deg);
                opacity: 0;
                filter: blur(50px) brightness(10);
            }
            15% {
                transform: translate(-50%, -50%) scale(1.4) rotate(15deg);
                opacity: 1;
                filter: blur(0) brightness(3);
            }
            30% {
                transform: translate(-50%, -50%) scale(1) rotate(-8deg);
                filter: blur(0) brightness(2);
            }
            45% {
                transform: translate(-50%, -50%) scale(1.2) rotate(5deg);
                filter: blur(0) brightness(1.5);
            }
            60% {
                transform: translate(-50%, -50%) scale(1) rotate(0);
                filter: blur(0) brightness(1.2);
            }
            75% {
                transform: translate(-50%, -50%) scale(1.05);
                filter: blur(0) brightness(1.1);
            }
            90% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
                filter: blur(0) brightness(1);
            }
            100% {
                transform: translate(-50%, -50%) scale(0.9);
                opacity: 0;
                filter: blur(20px) brightness(0.5);
            }
        }

        .heart-particle {
            position: absolute;
            font-size: 40px;
            opacity: 0;
            z-index: 1000;
            pointer-events: none;
            filter: drop-shadow(0 0 15px rgba(255, 51, 102, 0.8));
            animation: heartFly 2s ease-out forwards;
        }

        @keyframes heartFly {
            0% {
                transform: translate(0, 0) scale(0) rotate(0deg);
                opacity: 0;
            }
            20% {
                transform: translate(var(--tx), -30px) scale(1) rotate(0deg);
                opacity: 1;
            }
            50% {
                transform: translate(calc(var(--tx) * 1.5), -120px) scale(1.2) rotate(180deg);
                opacity: 0.8;
            }
            80% {
                transform: translate(calc(var(--tx) * 2), -180px) scale(0.8) rotate(360deg);
                opacity: 0.3;
            }
            100% {
                transform: translate(calc(var(--tx) * 2.5), -250px) scale(0) rotate(450deg);
                opacity: 0;
            }
        }

        .click-ripple {
            position: absolute;
            width: 1px;
            height: 1px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 154, 60, 0.6) 0%, rgba(255, 154, 60, 0) 70%);
            pointer-events: none;
            z-index: 100;
            transform: translate(-50%, -50%);
            animation: rippleExpand 0.8s ease-out forwards;
        }

        @keyframes rippleExpand {
            0% {
                width: 0;
                height: 0;
                opacity: 0.8;
                box-shadow: 0 0 0 0 rgba(255, 154, 60, 0.4);
            }
            100% {
                width: 150px;
                height: 150px;
                opacity: 0;
                box-shadow: 0 0 0 100px rgba(255, 154, 60, 0);
            }
        }

        /* –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ (—Ç–æ–ª—å–∫–æ –ø—Ä–∏ –Ω–∞–≤–µ–¥–µ–Ω–∏–∏) */
        .secret-progress {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 80px;
            height: 4px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 2px;
            overflow: hidden;
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 100;
        }

        .secret-progress:hover {
            opacity: 0.3;
        }

        .secret-progress-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #ff9a3c, #ff3366);
            border-radius: 2px;
            transition: width 0.3s ease-out;
        }

        /* –ü–æ–¥—Å–∫–∞–∑–∫–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è */
        .controls-hint {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.3);
            font-size: 14px;
            text-align: center;
            z-index: 10;
            pointer-events: none;
            padding: 12px 20px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 154, 60, 0.1);
            font-family: 'Courier New', monospace;
            letter-spacing: 1px;
            transition: all 1s ease;
        }

        .controls-hint.fade {
            opacity: 0.1;
            transform: translateX(-50%) translateY(10px);
        }

        /* –í—Å–ø—ã—à–∫–∞ –ø—Ä–∏ –≤–∑—Ä—ã–≤–µ */
        .explosion-flash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, 
                rgba(255, 100, 0, 0.8) 0%,
                rgba(255, 50, 0, 0.4) 30%,
                rgba(255, 0, 0, 0) 70%);
            z-index: 1500;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
        }

        @media (max-width: 768px) {
            .explosion-text {
                font-size: 80px;
            }
            
            .controls-hint {
                font-size: 12px;
                bottom: 20px;
                padding: 10px 15px;
            }
            
            .secret-progress {
                bottom: 10px;
                right: 10px;
                width: 60px;
            }
        }

        @media (max-width: 480px) {
            .explosion-text {
                font-size: 60px;
            }
            
            .controls-hint {
                font-size: 11px;
                bottom: 15px;
            }
        }
    </style>
</head>
<body>
    <!-- –ó–∞–≥—Ä—É–∑–∫–∞ -->
    <div class="loading" id="loading">
        <div class="spinner"></div>
        <div>üåå –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ—Å–º–∏—á–µ—Å–∫–æ–π —Å—Ü–µ–Ω—ã...</div>
    </div>

    <!-- –°–∫—Ä—ã—Ç—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã -->
    <div class="hidden-element" id="tapCounter">0</div>
    <div class="secret-progress" id="secretProgress">
        <div class="secret-progress-bar" id="progressBar"></div>
    </div>

    <!-- –≠—Ñ—Ñ–µ–∫—Ç—ã –≤–∑—Ä—ã–≤–∞ -->
    <div class="explosion-flash" id="explosionFlash"></div>
    <div class="explosion-text" id="explosionText">sosat bibijon‚ù§Ô∏è</div>

    <!-- –ü–æ–¥—Å–∫–∞–∑–∫–∞ -->
    <div class="controls-hint" id="controlsHint">
        –õ–ö–ú: –í–†–ê–©–ï–ù–ò–ï ‚Ä¢ –ö–û–õ–ï–°–û: –ú–ê–°–®–¢–ê–ë ‚Ä¢ –î–í–ê –ü–ê–õ–¨–¶–ê: –ü–†–ò–ë–õ–ò–ñ–ï–ù–ò–ï
    </div>

    <!-- –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è Three.js -->
    <div id="container"></div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // ============ –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø ============
        const CONFIG = {
            requiredTaps: 100,           // –†–æ–≤–Ω–æ 100 –∫–ª–∏–∫–æ–≤ –¥–ª—è –≤–∑—Ä—ã–≤–∞
            autoRotateSpeed: 0.3,        // –°–∫–æ—Ä–æ—Å—Ç—å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –≤—Ä–∞—â–µ–Ω–∏—è
            manualRotateSpeed: 0.8,      // –°–∫–æ—Ä–æ—Å—Ç—å –≤—Ä–∞—â–µ–Ω–∏—è –ø—Ä–∏ drag
            zoomSpeed: 0.001,            // –°–∫–æ—Ä–æ—Å—Ç—å –∑—É–º–∞
            starCount: 5000,             // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–≤–µ–∑–¥
            asteroidCount: 2000,         // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∞—Å—Ç–µ—Ä–æ–∏–¥–æ–≤
            explosionParticleCount: 800, // –ß–∞—Å—Ç–∏—Ü –ø—Ä–∏ –≤–∑—Ä—ã–≤–µ
            heartCount: 60,              // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–µ—Ä–¥–µ—á–µ–∫
            jupiterRadius: 5,            // –†–∞–¥–∏—É—Å –Æ–ø–∏—Ç–µ—Ä–∞
            ringInnerRadius: 7,          // –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π —Ä–∞–¥–∏—É—Å –∫–æ–ª–µ—Ü
            ringOuterRadius: 11,         // –í–Ω–µ—à–Ω–∏–π —Ä–∞–¥–∏—É—Å –∫–æ–ª–µ—Ü
            cameraDistance: 18,          // –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –∫–∞–º–µ—Ä—ã
            cameraMinDistance: 6,        // –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –ø—Ä–∏–±–ª–∏–∂–µ–Ω–∏–µ
            cameraMaxDistance: 40        // –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –æ—Ç–¥–∞–ª–µ–Ω–∏–µ
        };

        // ============ –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï ============
        let scene, camera, renderer;
        let jupiter, atmosphere, rings, particles, stars;
        let tapCount = 0;
        let isExploded = false;
        let explosionParticles = [];
        let lastTapTime = 0;
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let autoRotate = true;
        let autoRotateTimeout;

        // ============ –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ============
        function init() {
            console.log('üöÄ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ü–µ–Ω—ã...');
            
            // 1. –°–æ–∑–¥–∞–µ–º —Å—Ü–µ–Ω—É
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000010);
            
            // 2. –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –∫–∞–º–µ—Ä—É
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, CONFIG.cameraDistance);
            
            // 3. –°–æ–∑–¥–∞–µ–º —Ä–µ–Ω–¥–µ—Ä–µ—Ä —Å –±–∞–ª–∞–Ω—Å–æ–º –∫–∞—á–µ—Å—Ç–≤–∞/–ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                alpha: true,
                powerPreference: "high-performance"
            });
            
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.getElementById('container').appendChild(renderer.domElement);
            
            // 4. –°–æ–∑–¥–∞–µ–º –≤—Å–µ –æ–±—ä–µ–∫—Ç—ã —Å —Ö–æ—Ä–æ—à–µ–π –¥–µ—Ç–∞–ª–∏–∑–∞—Ü–∏–µ–π
            createStarField();
            createJupiter();
            createAtmosphere();
            createRings();
            createAsteroidBelt();
            createLighting();
            
            // 5. –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π
            setupEventListeners();
            
            // 6. –°–∫—Ä—ã–≤–∞–µ–º –∑–∞–≥—Ä—É–∑–∫—É
            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
                // –°–∫—Ä—ã–≤–∞–µ–º –ø–æ–¥—Å–∫–∞–∑–∫—É —á–µ—Ä–µ–∑ 8 —Å–µ–∫—É–Ω–¥
                setTimeout(() => {
                    document.getElementById('controlsHint').classList.add('fade');
                }, 8000);
            }, 2000);
            
            // 7. –ó–∞–ø—É—Å–∫–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é
            animate();
        }
        
        // ============ –°–û–ó–î–ê–ù–ò–ï –û–ë–™–ï–ö–¢–û–í ============
        function createStarField() {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(CONFIG.starCount * 3);
            const colors = new Float32Array(CONFIG.starCount * 3);
            const sizes = new Float32Array(CONFIG.starCount);
            
            for(let i = 0; i < CONFIG.starCount; i++) {
                const i3 = i * 3;
                
                // –°—Ñ–µ—Ä–∏—á–µ—Å–∫–æ–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ
                const radius = 500 + Math.random() * 1000;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                
                positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i3 + 1] = radius * Math.cos(phi);
                positions[i3 + 2] = radius * Math.sin(phi) * Math.sin(theta);
                
                // –†–µ–∞–ª–∏—Å—Ç–∏—á–Ω—ã–µ —Ü–≤–µ—Ç–∞ –∑–≤–µ–∑–¥
                const temperature = Math.random();
                if(temperature < 0.6) {
                    colors[i3] = 0.8;
                    colors[i3 + 1] = 0.85;
                    colors[i3 + 2] = 1.0;
                } else if(temperature < 0.85) {
                    colors[i3] = 1.0;
                    colors[i3 + 1] = 0.95;
                    colors[i3 + 2] = 0.9;
                } else if(temperature < 0.95) {
                    colors[i3] = 1.0;
                    colors[i3 + 1] = 0.85;
                    colors[i3 + 2] = 0.7;
                } else {
                    colors[i3] = 1.0;
                    colors[i3 + 1] = 0.7;
                    colors[i3 + 2] = 0.5;
                }
                
                sizes[i] = Math.random() * 2 + 0.5;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0.0 }
                },
                vertexShader: `
                    attribute float size;
                    attribute vec3 color;
                    varying vec3 vColor;
                    uniform float time;
                    
                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        
                        // –õ–µ–≥–∫–æ–µ –º–µ—Ä—Ü–∞–Ω–∏–µ
                        float flicker = sin(time * 2.0 + float(gl_VertexID) * 0.01) * 0.1 + 0.9;
                        
                        gl_PointSize = size * (300.0 / -mvPosition.z) * flicker;
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    
                    void main() {
                        float r = distance(gl_PointCoord, vec2(0.5, 0.5));
                        if(r > 0.5) discard;
                        
                        float alpha = 1.0 - smoothstep(0.0, 0.5, r);
                        gl_FragColor = vec4(vColor, alpha);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending
            });
            
            stars = new THREE.Points(geometry, material);
            scene.add(stars);
        }
        
        function createJupiter() {
            console.log('ü™ê –°–æ–∑–¥–∞–Ω–∏–µ –Æ–ø–∏—Ç–µ—Ä–∞...');
            
            // –ì–µ–æ–º–µ—Ç—Ä–∏—è —Å —Ö–æ—Ä–æ—à–µ–π –¥–µ—Ç–∞–ª–∏–∑–∞—Ü–∏–µ–π
            const geometry = new THREE.SphereGeometry(CONFIG.jupiterRadius, 96, 96);
            
            // –°–æ–∑–¥–∞–µ–º –∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω—É—é —Ç–µ–∫—Å—Ç—É—Ä—É
            const texture = createJupiterTexture();
            
            const material = new THREE.MeshStandardMaterial({
                map: texture,
                roughness: 0.7,
                metalness: 0.2,
                emissive: new THREE.Color(0x221100),
                emissiveIntensity: 0.05
            });
            
            jupiter = new THREE.Mesh(geometry, material);
            jupiter.castShadow = true;
            jupiter.receiveShadow = true;
            scene.add(jupiter);
        }
        
        function createJupiterTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 1536; // –•–æ—Ä–æ—à–∏–π –±–∞–ª–∞–Ω—Å –∫–∞—á–µ—Å—Ç–≤–∞
            canvas.height = 768;
            const ctx = canvas.getContext('2d');
            
            // –°–æ–∑–¥–∞–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π –≥—Ä–∞–¥–∏–µ–Ω—Ç
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
            gradient.addColorStop(0.0, '#FFE5B4');
            gradient.addColorStop(0.15, '#FFD8A8');
            gradient.addColorStop(0.35, '#FFB347');
            gradient.addColorStop(0.55, '#FF8C42');
            gradient.addColorStop(0.75, '#E68A2E');
            gradient.addColorStop(0.9, '#CC6E1D');
            gradient.addColorStop(1.0, '#B35917');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // –†–∏—Å—É–µ–º –∞—Ç–º–æ—Å—Ñ–µ—Ä–Ω—ã–µ –ø–æ–ª–æ—Å—ã
            ctx.strokeStyle = 'rgba(139, 69, 19, 0.85)';
            ctx.lineWidth = 18;
            
            for(let i = 0; i < 8; i++) {
                const y = i * 90 + 40;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.bezierCurveTo(
                    canvas.width * 0.3, y + Math.random() * 25 - 12.5,
                    canvas.width * 0.7, y + Math.random() * 25 - 12.5,
                    canvas.width, y
                );
                ctx.stroke();
            }
            
            // –ë–æ–ª—å—à–æ–µ –ö—Ä–∞—Å–Ω–æ–µ –ü—è—Ç–Ω–æ —Å –¥–µ—Ç–∞–ª—è–º–∏
            const spotX = canvas.width * 0.72;
            const spotY = canvas.height * 0.38;
            const spotWidth = 100;
            const spotHeight = 45;
            
            // –û—Å–Ω–æ–≤–Ω–æ–µ –ø—è—Ç–Ω–æ
            ctx.fillStyle = '#8B0000';
            ctx.beginPath();
            ctx.ellipse(spotX, spotY, spotWidth, spotHeight, Math.PI/5, 0, Math.PI * 2);
            ctx.fill();
            
            // –í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è —á–∞—Å—Ç—å
            ctx.fillStyle = '#A52A2A';
            ctx.beginPath();
            ctx.ellipse(spotX, spotY, spotWidth * 0.7, spotHeight * 0.7, Math.PI/5, 0, Math.PI * 2);
            ctx.fill();
            
            // –î–µ—Ç–∞–ª–∏ –ø—è—Ç–Ω–∞
            ctx.strokeStyle = '#FF4500';
            ctx.lineWidth = 3;
            ctx.globalAlpha = 0.6;
            
            for(let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const radius = spotWidth * 0.6;
                
                ctx.beginPath();
                ctx.arc(
                    spotX + Math.cos(angle) * radius * 0.5,
                    spotY + Math.sin(angle) * radius * 0.5,
                    radius * 0.2,
                    angle - Math.PI/3,
                    angle + Math.PI/3
                );
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
            
            // –ê—Ç–º–æ—Å—Ñ–µ—Ä–Ω—ã–µ –≤–∏—Ö—Ä–∏
            ctx.globalAlpha = 0.7;
            for(let i = 0; i < 25; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const size = Math.random() * 35 + 15;
                
                // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –µ—Å–ª–∏ –ø–æ–ø–∞–¥–∞–µ—Ç –Ω–∞ –ø—è—Ç–Ω–æ
                const distToSpot = Math.sqrt(Math.pow(x - spotX, 2) + Math.pow(y - spotY, 2));
                if(distToSpot < 150) continue;
                
                const colors = ['#FF6347', '#FF4500', '#FF8C00', '#DC143C'];
                const color = colors[Math.floor(Math.random() * colors.length)];
                
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
                
                // –°–ø–∏—Ä–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                for(let j = 0; j < size * 2; j += 2) {
                    const angle = j * 0.2;
                    const radius = j * 0.5;
                    
                    const spiralX = x + Math.cos(angle) * radius;
                    const spiralY = y + Math.sin(angle) * radius;
                    
                    if(j === 0) {
                        ctx.moveTo(spiralX, spiralY);
                    } else {
                        ctx.lineTo(spiralX, spiralY);
                    }
                }
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.ClampToEdgeWrapping;
            
            return texture;
        }
        
        function createAtmosphere() {
            const geometry = new THREE.SphereGeometry(CONFIG.jupiterRadius * 1.05, 64, 64);
            
            const material = new THREE.MeshBasicMaterial({
                color: 0x4488ff,
                transparent: true,
                opacity: 0.08,
                side: THREE.BackSide,
                blending: THREE.AdditiveBlending
            });
            
            atmosphere = new THREE.Mesh(geometry, material);
            scene.add(atmosphere);
        }
        
        function createRings() {
            // –û—Å–Ω–æ–≤–Ω–æ–µ –∫–æ–ª—å—Ü–æ
            const ringGeometry = new THREE.RingGeometry(
                CONFIG.ringInnerRadius, 
                CONFIG.ringOuterRadius, 
                128
            );
            
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFD8A8,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.07,
                blending: THREE.AdditiveBlending
            });
            
            rings = new THREE.Mesh(ringGeometry, ringMaterial);
            rings.rotation.x = Math.PI / 4;
            scene.add(rings);
            
            // –í–Ω—É—Ç—Ä–µ–Ω–Ω–µ–µ —Ç–æ–Ω–∫–æ–µ –∫–æ–ª—å—Ü–æ
            const innerRingGeometry = new THREE.RingGeometry(
                CONFIG.ringInnerRadius - 1, 
                CONFIG.ringInnerRadius, 
                64
            );
            
            const innerRingMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFB347,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.04
            });
            
            const innerRings = new THREE.Mesh(innerRingGeometry, innerRingMaterial);
            innerRings.rotation.x = Math.PI / 4.1;
            scene.add(innerRings);
        }
        
        function createAsteroidBelt() {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(CONFIG.asteroidCount * 3);
            const colors = new Float32Array(CONFIG.asteroidCount * 3);
            const sizes = new Float32Array(CONFIG.asteroidCount);
            
            for(let i = 0; i < CONFIG.asteroidCount; i++) {
                const i3 = i * 3;
                
                // –¢–æ—Ä–æ–∏–¥–∞–ª—å–Ω–æ–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ (–ø–æ—è—Å –∞—Å—Ç–µ—Ä–æ–∏–¥–æ–≤)
                const radius = 18 + Math.random() * 25;
                const angle = Math.random() * Math.PI * 2;
                const spread = (Math.random() - 0.5) * 8;
                
                positions[i3] = Math.cos(angle) * radius + spread;
                positions[i3 + 1] = (Math.random() - 0.5) * 15;
                positions[i3 + 2] = Math.sin(angle) * radius + spread;
                
                // –†–∞–∑–Ω—ã–µ —Ç–∏–ø—ã –∞—Å—Ç–µ—Ä–æ–∏–¥–æ–≤
                const asteroidType = Math.random();
                if(asteroidType < 0.4) {
                    // –õ–µ–¥—è–Ω—ã–µ
                    colors[i3] = 0.9;
                    colors[i3 + 1] = 0.95;
                    colors[i3 + 2] = 1.0;
                } else if(asteroidType < 0.7) {
                    // –ö–∞–º–µ–Ω–Ω—ã–µ
                    colors[i3] = 0.8;
                    colors[i3 + 1] = 0.7;
                    colors[i3 + 2] = 0.6;
                } else if(asteroidType < 0.9) {
                    // –ú–µ—Ç–∞–ª–ª–∏—á–µ—Å–∫–∏–µ
                    colors[i3] = 0.9;
                    colors[i3 + 1] = 0.9;
                    colors[i3 + 2] = 0.8;
                } else {
                    // –£–≥–ª–µ—Ä–æ–¥–∏—Å—Ç—ã–µ
                    colors[i3] = 0.4;
                    colors[i3 + 1] = 0.4;
                    colors[i3 + 2] = 0.4;
                }
                
                sizes[i] = Math.random() * 0.2 + 0.05;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            const material = new THREE.PointsMaterial({
                size: 0.1,
                vertexColors: true,
                transparent: true,
                sizeAttenuation: true
            });
            
            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }
        
        function createLighting() {
            // –û—Å–Ω–æ–≤–Ω–æ–π —Å–æ–ª–Ω–µ—á–Ω—ã–π —Å–≤–µ—Ç
            const sunLight = new THREE.DirectionalLight(0xFFFFFF, 1.5);
            sunLight.position.set(20, 15, 15);
            sunLight.castShadow = true;
            scene.add(sunLight);
            
            // –ó–∞–ø–æ–ª–Ω—è—é—â–∏–π —Å–≤–µ—Ç
            const fillLight = new THREE.DirectionalLight(0xFFB347, 0.4);
            fillLight.position.set(-10, -5, -5);
            scene.add(fillLight);
            
            // –ö–æ–Ω—Ç—Ä–æ–≤–æ–π —Å–≤–µ—Ç
            const backLight = new THREE.DirectionalLight(0xFFD8A8, 0.2);
            backLight.position.set(-5, 5, -15);
            scene.add(backLight);
            
            // –†–∞—Å—Å–µ—è–Ω–Ω—ã–π —Å–≤–µ—Ç
            const ambientLight = new THREE.AmbientLight(0x333344, 0.1);
            scene.add(ambientLight);
            
            // –í–∏–¥–∏–º–æ–µ –°–æ–ª–Ω—Ü–µ
            const sunGeometry = new THREE.SphereGeometry(2.5, 24, 24);
            const sunMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFFF00,
                emissive: 0xFFFF00,
                emissiveIntensity: 1.5
            });
            
            const sun = new THREE.Mesh(sunGeometry, sunMaterial);
            sun.position.copy(sunLight.position);
            scene.add(sun);
        }
        
        // ============ –£–ü–†–ê–í–õ–ï–ù–ò–ï –ò –°–ß–ï–¢–ß–ò–ö ============
        function setupEventListeners() {
            // –ú—ã—à—å –¥–ª—è –≤—Ä–∞—â–µ–Ω–∏—è
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('mouseleave', onMouseUp);
            
            // –ö–æ–ª–µ—Å–∏–∫–æ –¥–ª—è –∑—É–º–∞
            renderer.domElement.addEventListener('wheel', onMouseWheel);
            
            // –ö–∞—Å–∞–Ω–∏—è –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö
            renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
            renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
            renderer.domElement.addEventListener('touchend', onTouchEnd);
            
            // –ö–ª–∏–∫–∏ –¥–ª—è —Å—á–µ—Ç—á–∏–∫–∞ (—Ç–æ–ª—å–∫–æ –ø–æ –Æ–ø–∏—Ç–µ—Ä—É)
            renderer.domElement.addEventListener('click', handleClick);
            
            // –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–µ –º–µ–Ω—é
            renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());
            
            // –†–µ—Å–∞–π–∑ –æ–∫–Ω–∞
            window.addEventListener('resize', onWindowResize);
            
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –ø—Ä–∏ –Ω–∞–≤–µ–¥–µ–Ω–∏–∏
            document.getElementById('secretProgress').addEventListener('mouseenter', () => {
                document.getElementById('secretProgress').style.opacity = '0.3';
            });
            
            document.getElementById('secretProgress').addEventListener('mouseleave', () => {
                document.getElementById('secretProgress').style.opacity = '0';
            });
        }
        
        function onMouseDown(event) {
            isDragging = true;
            previousMousePosition = { x: event.clientX, y: event.clientY };
            autoRotate = false;
            clearTimeout(autoRotateTimeout);
        }
        
        function onMouseMove(event) {
            if (!isDragging || isExploded) return;
            
            const deltaX = event.clientX - previousMousePosition.x;
            const deltaY = event.clientY - previousMousePosition.y;
            
            if (jupiter) {
                jupiter.rotation.y += deltaX * CONFIG.manualRotateSpeed * 0.01;
                jupiter.rotation.x += deltaY * CONFIG.manualRotateSpeed * 0.01;
                
                // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –≤—Ä–∞—â–µ–Ω–∏–µ –ø–æ X
                jupiter.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, jupiter.rotation.x));
            }
            
            if (atmosphere) atmosphere.rotation.y = jupiter.rotation.y;
            
            previousMousePosition = { x: event.clientX, y: event.clientY };
        }
        
        function onMouseUp() {
            isDragging = false;
            // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∞–≤—Ç–æ-–≤—Ä–∞—â–µ–Ω–∏–µ —á–µ—Ä–µ–∑ 3 —Å–µ–∫—É–Ω–¥—ã –±–µ–∑–¥–µ–π—Å—Ç–≤–∏—è
            autoRotateTimeout = setTimeout(() => {
                autoRotate = true;
            }, 3000);
        }
        
        function onMouseWheel(event) {
            event.preventDefault();
            camera.position.z += event.deltaY * CONFIG.zoomSpeed;
            camera.position.z = Math.max(CONFIG.cameraMinDistance, Math.min(CONFIG.cameraMaxDistance, camera.position.z));
        }
        
        function onTouchStart(event) {
            event.preventDefault();
            if (event.touches.length === 1) {
                isDragging = true;
                previousMousePosition = { 
                    x: event.touches[0].clientX, 
                    y: event.touches[0].clientY 
                };
                autoRotate = false;
                clearTimeout(autoRotateTimeout);
            }
        }
        
        function onTouchMove(event) {
            event.preventDefault();
            
            if (event.touches.length === 1 && isDragging && !isExploded) {
                const deltaX = event.touches[0].clientX - previousMousePosition.x;
                const deltaY = event.touches[0].clientY - previousMousePosition.y;
                
                if (jupiter) {
                    jupiter.rotation.y += deltaX * CONFIG.manualRotateSpeed * 0.01;
                    jupiter.rotation.x += deltaY * CONFIG.manualRotateSpeed * 0.01;
                    
                    // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –≤—Ä–∞—â–µ–Ω–∏–µ –ø–æ X
                    jupiter.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, jupiter.rotation.x));
                }
                
                if (atmosphere) atmosphere.rotation.y = jupiter.rotation.y;
                
                previousMousePosition = { 
                    x: event.touches[0].clientX, 
                    y: event.touches[0].clientY 
                };
            } else if (event.touches.length === 2) {
                // –ú–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–≤—É–º—è –ø–∞–ª—å—Ü–∞–º–∏
                const touch1 = event.touches[0];
                const touch2 = event.touches[1];
                
                const currentDistance = Math.hypot(
                    touch1.clientX - touch2.clientX,
                    touch1.clientY - touch2.clientY
                );
                
                camera.position.z += (currentDistance * 0.01);
                camera.position.z = Math.max(CONFIG.cameraMinDistance, Math.min(CONFIG.cameraMaxDistance, camera.position.z));
            }
        }
        
        function onTouchEnd(event) {
            if (event.touches.length === 0) {
                isDragging = false;
                // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∞–≤—Ç–æ-–≤—Ä–∞—â–µ–Ω–∏–µ —á–µ—Ä–µ–∑ 3 —Å–µ–∫—É–Ω–¥—ã
                autoRotateTimeout = setTimeout(() => {
                    autoRotate = true;
                }, 3000);
            }
        }
        
        function handleClick(event) {
            if (isExploded) return;
            
            const rect = renderer.domElement.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –ø–æ–ø–∞–ª–∏ –ª–∏ –ø–æ –Æ–ø–∏—Ç–µ—Ä—É
            const mouse = new THREE.Vector2();
            mouse.x = (x / rect.width) * 2 - 1;
            mouse.y = -(y / rect.height) * 2 + 1;
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            
            if (jupiter) {
                const intersects = raycaster.intersectObject(jupiter);
                
                if (intersects.length > 0) {
                    processJupiterTap(x, y);
                }
            }
        }
        
        function processJupiterTap(x, y) {
            // –°–æ–∑–¥–∞–µ–º —ç—Ñ—Ñ–µ–∫—Ç –∫–ª–∏–∫–∞
            createClickRipple(x, y);
            
            // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫
            tapCount++;
            document.getElementById('tapCounter').textContent = tapCount;
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä
            const progress = (tapCount / CONFIG.requiredTaps) * 100;
            document.getElementById('progressBar').style.width = `${progress}%`;
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –¥–æ—Å—Ç–∏–≥–ª–∏ –ª–∏ 100 –∫–ª–∏–∫–æ–≤
            if (tapCount === CONFIG.requiredTaps) {
                explodeJupiter();
            }
            
            console.log(`–°–µ–∫—Ä–µ—Ç–Ω—ã–π —Å—á–µ—Ç—á–∏–∫: ${tapCount}/100`);
        }
        
        function createClickRipple(x, y) {
            const ripple = document.createElement('div');
            ripple.className = 'click-ripple';
            ripple.style.left = `${x}px`;
            ripple.style.top = `${y}px`;
            document.body.appendChild(ripple);
            
            setTimeout(() => {
                if (ripple.parentNode) {
                    ripple.parentNode.removeChild(ripple);
                }
            }, 800);
        }
        
        // ============ –í–ó–†–´–í –Æ–ü–ò–¢–ï–†–ê ============
        function explodeJupiter() {
            if (isExploded) return;
            isExploded = true;
            
            console.log('üí• –í–ó–†–´–í –Æ–ü–ò–¢–ï–†–ê –ù–ê 100 –ö–õ–ò–ö–ï!');
            
            // –û—Ç–∫–ª—é—á–∞–µ–º –∞–≤—Ç–æ-–≤—Ä–∞—â–µ–Ω–∏–µ
            autoRotate = false;
            clearTimeout(autoRotateTimeout);
            
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –≤—Å–ø—ã—à–∫—É
            const flash = document.getElementById('explosionFlash');
            flash.style.opacity = '0.8';
            setTimeout(() => {
                flash.style.opacity = '0';
            }, 500);
            
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–µ–∫—Å—Ç
            document.getElementById('explosionText').classList.add('visible');
            
            // –°–æ–∑–¥–∞–µ–º —Å–µ—Ä–¥–µ—á–∫–∏
            createHeartParticles();
            
            // –°–æ–∑–¥–∞–µ–º —á–∞—Å—Ç–∏—Ü—ã –≤–∑—Ä—ã–≤–∞
            createExplosionParticles();
            
            // –£–¥–∞–ª—è–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π –Æ–ø–∏—Ç–µ—Ä —Å –∑–∞–¥–µ—Ä–∂–∫–æ–π
            setTimeout(() => {
                if (jupiter) scene.remove(jupiter);
                if (atmosphere) scene.remove(atmosphere);
                if (rings) scene.remove(rings);
                
                // –°–æ—Ç—Ä—è—Å–µ–Ω–∏–µ –∫–∞–º–µ—Ä—ã
                shakeCamera();
            }, 300);
            
            // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —á–µ—Ä–µ–∑ 7 —Å–µ–∫—É–Ω–¥
            setTimeout(() => {
                resetJupiter();
            }, 7000);
        }
        
        function createExplosionParticles() {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(CONFIG.explosionParticleCount * 3);
            const colors = new Float32Array(CONFIG.explosionParticleCount * 3);
            const velocities = [];
            
            for(let i = 0; i < CONFIG.explosionParticleCount; i++) {
                const i3 = i * 3;
                
                // –ù–∞—á–∞–ª—å–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è –Ω–∞ –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏ –Æ–ø–∏—Ç–µ—Ä–∞
                const phi = Math.random() * Math.PI * 2;
                const theta = Math.random() * Math.PI;
                const radius = CONFIG.jupiterRadius;
                
                positions[i3] = radius * Math.sin(theta) * Math.cos(phi);
                positions[i3 + 1] = radius * Math.cos(theta);
                positions[i3 + 2] = radius * Math.sin(theta) * Math.sin(phi);
                
                // –¶–≤–µ—Ç–∞ —á–∞—Å—Ç–∏—Ü –≤–∑—Ä—ã–≤–∞
                const colorType = Math.random();
                if(colorType < 0.3) {
                    // –ö—Ä–∞—Å–Ω—ã–µ
                    colors[i3] = 1.0;
                    colors[i3 + 1] = 0.2 + Math.random() * 0.1;
                    colors[i3 + 2] = 0.2;
                } else if(colorType < 0.6) {
                    // –û—Ä–∞–Ω–∂–µ–≤—ã–µ
                    colors[i3] = 1.0;
                    colors[i3 + 1] = 0.5 + Math.random() * 0.2;
                    colors[i3 + 2] = 0.0;
                } else if(colorType < 0.8) {
                    // –ñ–µ–ª—Ç—ã–µ
                    colors[i3] = 1.0;
                    colors[i3 + 1] = 0.9 + Math.random() * 0.1;
                    colors[i3 + 2] = 0.3;
                } else {
                    // –ë–µ–ª—ã–µ (–≥–æ—Ä—è—á–∏–µ)
                    colors[i3] = 1.0;
                    colors[i3 + 1] = 1.0;
                    colors[i3 + 2] = 1.0;
                }
                
                // –°–ª—É—á–∞–π–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å –∏ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
                velocities.push({
                    x: (Math.random() - 0.5) * 0.25,
                    y: (Math.random() - 0.5) * 0.25,
                    z: (Math.random() - 0.5) * 0.25,
                    life: 120 + Math.random() * 60
                });
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 0.3,
                vertexColors: true,
                transparent: true,
                blending: THREE.AdditiveBlending
            });
            
            const particleSystem = new THREE.Points(geometry, material);
            particleSystem.userData = { velocities };
            scene.add(particleSystem);
            explosionParticles.push(particleSystem);
        }
        
        function createHeartParticles() {
            for(let i = 0; i < CONFIG.heartCount; i++) {
                setTimeout(() => {
                    const heart = document.createElement('div');
                    heart.className = 'heart-particle';
                    heart.innerHTML = '‚ù§Ô∏è';
                    heart.style.left = `${Math.random() * 100}vw`;
                    heart.style.top = `${Math.random() * 100}vh`;
                    heart.style.setProperty('--tx', `${(Math.random() - 0.5) * 250}px`);
                    heart.style.fontSize = `${Math.random() * 30 + 25}px`;
                    heart.style.opacity = '1';
                    
                    document.body.appendChild(heart);
                    
                    setTimeout(() => {
                        if (heart.parentNode) {
                            heart.parentNode.removeChild(heart);
                        }
                    }, 2000);
                }, i * 30); // –†–∞–∑–Ω–µ—Å–µ–º –ø–æ—è–≤–ª–µ–Ω–∏–µ
            }
        }
        
        function shakeCamera() {
            const originalPosition = camera.position.clone();
            const intensity = 0.4;
            let time = 0;
            
            function shake() {
                if (time < 1.5) {
                    time += 0.02;
                    const progress = 1 - (time / 1.5);
                    
                    camera.position.x = originalPosition.x + (Math.random() - 0.5) * intensity * progress;
                    camera.position.y = originalPosition.y + (Math.random() - 0.5) * intensity * progress;
                    camera.position.z = originalPosition.z + (Math.random() - 0.5) * intensity * progress * 0.5;
                    
                    requestAnimationFrame(shake);
                } else {
                    camera.position.copy(originalPosition);
                }
            }
            
            shake();
        }
        
        function resetJupiter() {
            isExploded = false;
            tapCount = 0;
            
            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º UI
            document.getElementById('tapCounter').textContent = '0';
            document.getElementById('progressBar').style.width = '0%';
            document.getElementById('explosionText').classList.remove('visible');
            
            // –£–¥–∞–ª—è–µ–º —á–∞—Å—Ç–∏—Ü—ã –≤–∑—Ä—ã–≤–∞
            explosionParticles.forEach(particleSystem => {
                scene.remove(particleSystem);
            });
            explosionParticles = [];
            
            // –í–∫–ª—é—á–∞–µ–º –∞–≤—Ç–æ-–≤—Ä–∞—â–µ–Ω–∏–µ
            autoRotate = true;
            
            // –í–æ—Å—Å–æ–∑–¥–∞–µ–º –Æ–ø–∏—Ç–µ—Ä
            createJupiter();
            createAtmosphere();
            createRings();
            
            console.log('üîÑ –Æ–ø–∏—Ç–µ—Ä –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω!');
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // ============ –ê–ù–ò–ú–ê–¶–ò–Ø ============
        function animate() {
            requestAnimationFrame(animate);
            
            const time = Date.now() * 0.001;
            
            // –ê–≤—Ç–æ-–≤—Ä–∞—â–µ–Ω–∏–µ
            if (jupiter && autoRotate && !isExploded) {
                jupiter.rotation.y += 0.005 * CONFIG.autoRotateSpeed;
                if (atmosphere) atmosphere.rotation.y = jupiter.rotation.y;
            }
            
            // –í—Ä–∞—â–µ–Ω–∏–µ –∑–≤–µ–∑–¥
            if (stars) {
                stars.material.uniforms.time.value = time;
                stars.rotation.y += 0.0001;
            }
            
            // –í—Ä–∞—â–µ–Ω–∏–µ –∫–æ–ª–µ—Ü
            if (rings && !isExploded) {
                rings.rotation.z += 0.001;
            }
            
            // –í—Ä–∞—â–µ–Ω–∏–µ –∞—Å—Ç–µ—Ä–æ–∏–¥–æ–≤
            if (particles && !isExploded) {
                particles.rotation.y += 0.0005;
            }
            
            // –î–≤–∏–∂–µ–Ω–∏–µ –°–æ–ª–Ω—Ü–∞
            const sunAngle = time * 0.03;
            const sunDistance = 25;
            
            scene.children.forEach(child => {
                if (child.isLight && child.position.length() > 20) {
                    child.position.x = Math.cos(sunAngle) * sunDistance;
                    child.position.z = Math.sin(sunAngle) * sunDistance;
                    
                    // –û–±–Ω–æ–≤–ª—è–µ–º –≤–∏–¥–∏–º–æ–µ —Å–æ–ª–Ω—Ü–µ
                    const sun = scene.children.find(c => 
                        c.isMesh && c.position.distanceTo(child.position) < 5);
                    if (sun) {
                        sun.position.copy(child.position);
                    }
                }
            });
            
            // –ê–Ω–∏–º–∞—Ü–∏—è —á–∞—Å—Ç–∏—Ü –≤–∑—Ä—ã–≤–∞
            explosionParticles.forEach((particleSystem, index) => {
                const positions = particleSystem.geometry.attributes.position.array;
                const velocities = particleSystem.userData.velocities;
                
                for(let i = 0; i < positions.length; i += 3) {
                    const particleIndex = i / 3;
                    const vel = velocities[particleIndex];
                    
                    if (vel.life > 0) {
                        vel.life -= 1;
                        
                        // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é
                        positions[i] += vel.x;
                        positions[i + 1] += vel.y;
                        positions[i + 2] += vel.z;
                        
                        // –ì—Ä–∞–≤–∏—Ç–∞—Ü–∏—è
                        vel.y -= 0.003;
                        
                        // –ó–∞–º–µ–¥–ª–µ–Ω–∏–µ
                        vel.x *= 0.99;
                        vel.y *= 0.99;
                        vel.z *= 0.99;
                        
                        // –≠—Ñ—Ñ–µ–∫—Ç –∏—Å—á–µ–∑–Ω–æ–≤–µ–Ω–∏—è
                        const lifeFactor = vel.life / 120;
                        if (lifeFactor < 0.3) {
                            positions[i] *= 0.99;
                            positions[i + 1] *= 0.99;
                            positions[i + 2] *= 0.99;
                        }
                    }
                }
                
                particleSystem.geometry.attributes.position.needsUpdate = true;
                
                // –£–¥–∞–ª—è–µ–º —Å–∏—Å—Ç–µ–º—É –∫–æ–≥–¥–∞ –≤—Å–µ —á–∞—Å—Ç–∏—Ü—ã —É–º–µ—Ä–ª–∏
                if (velocities.every(v => v.life <= 0)) {
                    scene.remove(particleSystem);
                    explosionParticles.splice(index, 1);
                }
            });
            
            // –†–µ–Ω–¥–µ—Ä–∏–Ω–≥
            renderer.render(scene, camera);
        }
        
        // ============ –ó–ê–ü–£–°–ö ============
        function checkWebGL() {
            try {
                const canvas = document.createElement('canvas');
                return !!(window.WebGLRenderingContext && 
                         (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
            } catch (e) {
                return false;
            }
        }
        
        if (checkWebGL()) {
            init();
        } else {
            document.getElementById('loading').innerHTML = `
                <div style="text-align: center; color: #ff4444; padding: 20px;">
                    <h2>‚ö†Ô∏è WebGL –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è</h2>
                    <p>–û–±–Ω–æ–≤–∏—Ç–µ –±—Ä–∞—É–∑–µ—Ä –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ Chrome/Firefox</p>
                </div>
            `;
        }
    </script>
</body>
</html>