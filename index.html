<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D –Æ–ø–∏—Ç–µ—Ä - –ö–æ—Å–º–∏—á–µ—Å–∫–æ–µ —Å–æ–≤–µ—Ä—à–µ–Ω—Å—Ç–≤–æ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000000;
            overflow: hidden;
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
            height: 100vh;
            width: 100vw;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            cursor: grab;
        }

        body:active {
            cursor: grabbing;
        }

        #container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, #000000, #0a0a2a);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            color: #ff9a3c;
            font-size: 24px;
            flex-direction: column;
            gap: 30px;
            transition: opacity 1.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-spinner {
            width: 80px;
            height: 80px;
            border: 4px solid rgba(255, 154, 60, 0.1);
            border-top: 4px solid #ff9a3c;
            border-radius: 50%;
            animation: spin 1.2s cubic-bezier(0.68, -0.55, 0.27, 1.55) infinite;
            box-shadow: 0 0 30px rgba(255, 154, 60, 0.3);
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            text-align: center;
            line-height: 1.6;
            max-width: 500px;
            padding: 0 20px;
        }

        .loading-text .title {
            font-size: 32px;
            font-weight: 700;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #ff9a3c, #ff6b6b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .loading-text .subtitle {
            font-size: 16px;
            color: rgba(255, 255, 255, 0.6);
            font-weight: 300;
        }

        /* –°–∫—Ä—ã—Ç—ã–π —Å—á–µ—Ç—á–∏–∫ - –Ω–µ–≤–∏–¥–∏–º –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è */
        .counter {
            position: fixed;
            top: -100px;
            left: -100px;
            opacity: 0;
            pointer-events: none;
        }

        /* –≠—Ñ—Ñ–µ–∫—Ç –≤–∑—Ä—ã–≤–∞ */
        .explosion-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, 
                rgba(255, 0, 0, 0) 0%,
                rgba(255, 50, 0, 0.1) 30%,
                rgba(255, 100, 0, 0.2) 50%,
                rgba(255, 150, 0, 0) 100%);
            z-index: 9000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease-out;
        }

        .explosion-text {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 140px;
            font-weight: 900;
            color: #ff3366;
            text-shadow: 
                0 0 30px #ff0066,
                0 0 60px #ff3366,
                0 0 90px #ff6699,
                0 0 120px #ff99cc;
            z-index: 10000;
            opacity: 0;
            pointer-events: none;
            font-family: 'Impact', 'Arial Black', sans-serif;
            text-align: center;
            line-height: 1.2;
            letter-spacing: 2px;
            filter: blur(0);
            transition: all 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .explosion-text.visible {
            opacity: 1;
            animation: textReveal 3s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }

        @keyframes textReveal {
            0% {
                transform: translate(-50%, -50%) scale(0.1) rotate(-90deg);
                opacity: 0;
                filter: blur(50px) brightness(10);
            }
            20% {
                transform: translate(-50%, -50%) scale(1.3) rotate(10deg);
                opacity: 1;
                filter: blur(0) brightness(3);
            }
            30% {
                transform: translate(-50%, -50%) scale(1) rotate(-5deg);
                filter: blur(0) brightness(2);
            }
            40% {
                transform: translate(-50%, -50%) scale(1.1) rotate(3deg);
                filter: blur(0) brightness(1.5);
            }
            50% {
                transform: translate(-50%, -50%) scale(1) rotate(0);
                filter: blur(0) brightness(1.2);
            }
            60% {
                transform: translate(-50%, -50%) scale(1.05);
                filter: blur(0) brightness(1.1);
            }
            70% {
                transform: translate(-50%, -50%) scale(1);
                filter: blur(0) brightness(1);
            }
            80% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
                filter: blur(0) brightness(1);
            }
            90% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.8;
                filter: blur(0) brightness(0.8);
            }
            100% {
                transform: translate(-50%, -50%) scale(0.9);
                opacity: 0;
                filter: blur(20px) brightness(0.5);
            }
        }

        .heart-particle {
            position: absolute;
            font-size: 40px;
            opacity: 0;
            z-index: 8000;
            pointer-events: none;
            filter: drop-shadow(0 0 10px rgba(255, 51, 102, 0.7));
        }

        /* –ü–æ–¥—Å–∫–∞–∑–∫–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è */
        .hint {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.4);
            font-size: 14px;
            text-align: center;
            z-index: 10;
            pointer-events: none;
            font-family: 'Courier New', monospace;
            letter-spacing: 1px;
            padding: 15px 25px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 154, 60, 0.1);
            transition: all 0.5s ease;
        }

        .hint.fade-out {
            opacity: 0;
            transform: translateX(-50%) translateY(20px);
        }

        /* –≠—Ñ—Ñ–µ–∫—Ç –ø—É–ª—å—Å–∞—Ü–∏–∏ –ø—Ä–∏ –∫–ª–∏–∫–µ */
        .click-effect {
            position: absolute;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 154, 60, 0.4) 0%, rgba(255, 154, 60, 0) 70%);
            pointer-events: none;
            z-index: 500;
            transform: translate(-50%, -50%);
            animation: ripple 0.8s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }

        @keyframes ripple {
            0% {
                width: 0;
                height: 0;
                opacity: 0.8;
            }
            100% {
                width: 300px;
                height: 300px;
                opacity: 0;
            }
        }

        /* –¢–∞–π–Ω—ã–π –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä (–æ—á–µ–Ω—å –ø—Ä–æ–∑—Ä–∞—á–Ω—ã–π) */
        .secret-progress {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 100px;
            height: 4px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 2px;
            overflow: hidden;
            opacity: 0.1;
            transition: opacity 0.3s;
            z-index: 100;
        }

        .secret-progress:hover {
            opacity: 0.3;
        }

        .secret-progress-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #ff9a3c, #ff3366);
            border-radius: 2px;
            transition: width 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        /* –°–µ–∫—Ä–µ—Ç–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ (–ø–æ—è–≤–ª—è–µ—Ç—Å—è –ø—Ä–∏ –ø—Ä–∏–±–ª–∏–∂–µ–Ω–∏–∏) */
        .secret-notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ff3366;
            border-radius: 20px;
            padding: 30px;
            text-align: center;
            z-index: 10000;
            opacity: 0;
            transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            backdrop-filter: blur(20px);
            box-shadow: 0 0 100px rgba(255, 51, 102, 0.5);
        }

        .secret-notification.visible {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }

        .secret-notification h3 {
            color: #ff3366;
            font-size: 28px;
            margin-bottom: 15px;
            font-weight: 700;
        }

        .secret-notification p {
            color: rgba(255, 255, 255, 0.8);
            font-size: 18px;
            line-height: 1.5;
            margin-bottom: 20px;
        }

        .secret-notification .count {
            font-size: 48px;
            font-weight: 900;
            color: #ff9a3c;
            margin: 20px 0;
        }

        /* –ê–¥–∞–ø—Ç–∏–≤–Ω–æ—Å—Ç—å */
        @media (max-width: 768px) {
            .loading-text .title {
                font-size: 24px;
            }
            
            .hint {
                font-size: 12px;
                bottom: 15px;
                padding: 10px 15px;
            }
            
            .explosion-text {
                font-size: 80px;
            }
            
            .secret-progress {
                bottom: 10px;
                right: 10px;
                width: 80px;
            }
        }

        @media (max-width: 480px) {
            .loading {
                font-size: 18px;
            }
            
            .loading-spinner {
                width: 60px;
                height: 60px;
            }
            
            .loading-text .title {
                font-size: 20px;
            }
            
            .explosion-text {
                font-size: 60px;
            }
        }
    </style>
</head>
<body>
    <!-- –ó–∞–≥—Ä—É–∑–∫–∞ -->
    <div class="loading" id="loading">
        <div class="loading-spinner"></div>
        <div class="loading-text">
            <div class="title">3D –Æ–ü–ò–¢–ï–†</div>
            <div class="subtitle">–ó–∞–≥—Ä—É–∑–∫–∞ –¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –º–æ–¥–µ–ª–∏ –≥–∞–∑–æ–≤–æ–≥–æ –≥–∏–≥–∞–Ω—Ç–∞...</div>
        </div>
    </div>

    <!-- –°–∫—Ä—ã—Ç—ã–π —Å—á–µ—Ç—á–∏–∫ -->
    <div class="counter" id="counter">0</div>

    <!-- –°–µ–∫—Ä–µ—Ç–Ω—ã–π –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä -->
    <div class="secret-progress" id="secretProgress">
        <div class="secret-progress-bar" id="progressBar"></div>
    </div>

    <!-- –≠—Ñ—Ñ–µ–∫—Ç—ã –≤–∑—Ä—ã–≤–∞ -->
    <div class="explosion-overlay" id="explosionOverlay"></div>
    <div class="explosion-text" id="explosionText">sosat bibijon‚ù§Ô∏è</div>

    <!-- –°–µ–∫—Ä–µ—Ç–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ -->
    <div class="secret-notification" id="secretNotification">
        <h3>–°–ï–ö–†–ï–¢–ù–ê–Ø –ú–ò–°–°–ò–Ø</h3>
        <p>–í—ã –ø—Ä–∏–±–ª–∏–∂–∞–µ—Ç–µ—Å—å –∫ —á–µ–º—É-—Ç–æ –æ—Å–æ–±–µ–Ω–Ω–æ–º—É...</p>
        <div class="count" id="secretCount">0</div>
        <p>–ü—Ä–æ–¥–æ–ª–∂–∞–π—Ç–µ –∏—Å—Å–ª–µ–¥–æ–≤–∞—Ç—å –ø–ª–∞–Ω–µ—Ç—É</p>
    </div>

    <!-- –ü–æ–¥—Å–∫–∞–∑–∫–∞ -->
    <div class="hint" id="hint">
        ü™ê –ö–ê–°–ê–ô–¢–ï–°–¨ –ò –í–†–ê–©–ê–ô–¢–ï –Æ–ü–ò–¢–ï–† ‚Ä¢ üîç –ü–†–ò–ë–õ–ò–ñ–ê–ô–¢–ï –î–í–£–ú–Ø –ü–ê–õ–¨–¶–ê–ú–ò
    </div>

    <!-- –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è Three.js -->
    <div id="container"></div>

    <!-- Three.js –∏ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.min.js"></script>
    
    <script>
        // ============ –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø ============
        const CONFIG = {
            tapCountForExplosion: 100,        // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–∞–ø–æ–≤ –¥–ª—è –≤–∑—Ä—ã–≤–∞
            highQuality: true,                // –í—ã—Å–æ–∫–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ –≥—Ä–∞—Ñ–∏–∫–∏
            rotationSpeed: 0.15,              // –°–∫–æ—Ä–æ—Å—Ç—å –≤—Ä–∞—â–µ–Ω–∏—è –Æ–ø–∏—Ç–µ—Ä–∞
            particleCount: 10000,             // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–≤–µ–∑–¥
            showSecretNotificationAt: 50,     // –ü–æ–∫–∞–∑–∞—Ç—å —Å–µ–∫—Ä–µ—Ç–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø—Ä–∏ N —Ç–∞–ø–∞—Ö
        };

        // ============ –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï ============
        let scene, camera, renderer, controls;
        let jupiter, atmosphere, clouds, rings, particles, starField, galaxy;
        let composer, bloomPass;
        let clock = new THREE.Clock();
        let tapCount = 0;
        let isExploded = false;
        let explosionParticles = [];
        let clickEffects = [];
        let heartParticles = [];

        // ============ –®–ï–ô–î–ï–†–´ –î–õ–Ø –í–´–°–û–ö–û–ö–ê–ß–ï–°–¢–í–ï–ù–ù–û–ô –ì–†–ê–§–ò–ö–ò ============
        const atmosphereVertexShader = `
            varying vec3 vNormal;
            varying vec3 vPosition;
            
            void main() {
                vNormal = normalize(normalMatrix * normal);
                vPosition = position;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const atmosphereFragmentShader = `
            uniform float time;
            varying vec3 vNormal;
            varying vec3 vPosition;
            
            void main() {
                float intensity = pow(0.85 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 3.0);
                
                // –ü–ª–∞–≤–Ω–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ —Ü–≤–µ—Ç–∞
                vec3 color1 = vec3(0.2, 0.4, 0.8);
                vec3 color2 = vec3(0.8, 0.5, 0.2);
                vec3 color = mix(color1, color2, sin(time * 0.3 + vPosition.y * 0.5) * 0.5 + 0.5);
                
                // –ú–µ—Ä—Ü–∞–Ω–∏–µ
                float flicker = sin(time * 2.0 + vPosition.x * 0.5) * 0.1 + 0.9;
                
                gl_FragColor = vec4(color, intensity * 0.15 * flicker);
            }
        `;

        const cloudVertexShader = `
            varying vec2 vUv;
            varying vec3 vPosition;
            
            void main() {
                vUv = uv;
                vPosition = position;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const cloudFragmentShader = `
            uniform float time;
            uniform sampler2D cloudTexture;
            varying vec2 vUv;
            varying vec3 vPosition;
            
            void main() {
                // –ê–Ω–∏–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ UV –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –¥–ª—è –æ–±–ª–∞–∫–æ–≤
                vec2 animatedUV = vUv * 2.0 + vec2(time * 0.02, time * 0.01);
                
                // –°–æ–∑–¥–∞–µ–º —Ç—É—Ä–±—É–ª–µ–Ω—Ç–Ω–æ—Å—Ç—å
                float turbulence = sin(vUv.x * 10.0 + time * 0.5) * 0.1 + 
                                  sin(vUv.y * 8.0 + time * 0.3) * 0.1;
                
                vec2 distortedUV = animatedUV + vec2(turbulence, turbulence * 0.7);
                
                // –¶–≤–µ—Ç –æ–±–ª–∞–∫–æ–≤
                vec3 cloudColor = vec3(1.0, 1.0, 1.0);
                float cloudDensity = texture2D(cloudTexture, distortedUV).r;
                
                // –ì—Ä–∞–¥–∏–µ–Ω—Ç –¥–ª—è —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω–æ—Å—Ç–∏
                float gradient = smoothstep(0.3, 0.7, vUv.y);
                float alpha = cloudDensity * 0.2 * gradient;
                
                gl_FragColor = vec4(cloudColor, alpha);
            }
        `;

        // ============ –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ============
        function init() {
            console.log('üöÄ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ü–µ–Ω—ã –≤—ã—Å–æ—á–∞–π—à–µ–≥–æ –∫–∞—á–µ—Å—Ç–≤–∞...');
            
            // 1. –°–æ–∑–¥–∞–µ–º —Å—Ü–µ–Ω—É —Å —Ç—É–º–∞–Ω–æ–º
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000010, 0.001);
            
            // 2. –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –∫–∞–º–µ—Ä—É
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 0, 20);
            
            // 3. –°–æ–∑–¥–∞–µ–º —Ä–µ–Ω–¥–µ—Ä–µ—Ä —Å –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–º–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                alpha: true,
                powerPreference: "high-performance",
                precision: "highp"
            });
            
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.3;
            renderer.outputEncoding = THREE.sRGBEncoding;
            document.getElementById('container').appendChild(renderer.domElement);
            
            // 4. –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –ø—Ä–æ–¥–≤–∏–Ω—É—Ç–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.rotateSpeed = 0.8;
            controls.minDistance = 8;
            controls.maxDistance = 100;
            controls.maxPolarAngle = Math.PI;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.3;
            
            // 5. –°–æ–∑–¥–∞–µ–º –ø–æ—Å—Ç–æ–±—Ä–∞–±–æ—Ç–∫—É (Bloom —ç—Ñ—Ñ–µ–∫—Ç)
            composer = new THREE.EffectComposer(renderer);
            composer.addPass(new THREE.RenderPass(scene, camera));
            
            bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.2, 0.4, 0.85
            );
            composer.addPass(bloomPass);
            
            // 6. –°–æ–∑–¥–∞–µ–º –≤—Å–µ –æ–±—ä–µ–∫—Ç—ã —Å –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π –¥–µ—Ç–∞–ª–∏–∑–∞—Ü–∏–µ–π
            createUniverse();
            createJupiter();
            createAtmosphere();
            createClouds();
            createRings();
            createAsteroidBelt();
            createLighting();
            
            // 7. –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π
            setupEventListeners();
            
            // 8. –°–∫—Ä—ã–≤–∞–µ–º —ç–∫—Ä–∞–Ω –∑–∞–≥—Ä—É–∑–∫–∏ —Å –∞–Ω–∏–º–∞—Ü–∏–µ–π
            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
                setTimeout(() => {
                    document.getElementById('hint').classList.add('fade-out');
                }, 8000);
            }, 3000);
            
            // 9. –ó–∞–ø—É—Å–∫–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é
            animate();
        }
        
        // ============ –°–û–ó–î–ê–ù–ò–ï –û–ë–™–ï–ö–¢–û–í –° –ú–ê–ö–°–ò–ú–ê–õ–¨–ù–û–ô –î–ï–¢–ê–õ–ò–ó–ê–¶–ò–ï–ô ============
        function createUniverse() {
            // –§–æ–Ω–æ–≤—ã–µ –≥–∞–ª–∞–∫—Ç–∏–∫–∏ –∏ —Ç—É–º–∞–Ω–Ω–æ—Å—Ç–∏
            createGalaxies();
            
            // –ó–≤–µ–∑–¥–Ω–æ–µ –ø–æ–ª–µ —Å —Ä–∞–∑–Ω—ã–º–∏ —Ü–≤–µ—Ç–∞–º–∏ –∑–≤–µ–∑–¥
            createStarField();
        }
        
        function createGalaxies() {
            // –°–æ–∑–¥–∞–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ –¥–∞–ª–µ–∫–∏—Ö –≥–∞–ª–∞–∫—Ç–∏–∫
            for(let g = 0; g < 3; g++) {
                const galaxyGroup = new THREE.Group();
                
                // –ü–æ–∑–∏—Ü–∏—è –≤ –¥–∞–ª–µ–∫–æ–º –∫–æ—Å–º–æ—Å–µ
                const distance = 1500 + Math.random() * 1000;
                const angle = Math.random() * Math.PI * 2;
                const height = (Math.random() - 0.5) * 800;
                
                galaxyGroup.position.set(
                    Math.cos(angle) * distance,
                    height,
                    Math.sin(angle) * distance
                );
                
                // –°–ø–∏—Ä–∞–ª—å–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞
                const starCount = 2000;
                const positions = new Float32Array(starCount * 3);
                const colors = new Float32Array(starCount * 3);
                
                for(let i = 0; i < starCount; i++) {
                    const i3 = i * 3;
                    
                    // –°–ø–∏—Ä–∞–ª—å–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
                    const arm = Math.floor(Math.random() * 4);
                    const distance = Math.random() * 50 + 10;
                    const angle = (arm * Math.PI / 2) + Math.random() * Math.PI / 2;
                    
                    const spiralX = Math.cos(angle) * distance;
                    const spiralZ = Math.sin(angle) * distance;
                    const spiralY = (Math.random() - 0.5) * 15;
                    
                    positions[i3] = spiralX;
                    positions[i3 + 1] = spiralY;
                    positions[i3 + 2] = spiralZ;
                    
                    // –¶–≤–µ—Ç–∞ –∑–≤–µ–∑–¥ –≤ –≥–∞–ª–∞–∫—Ç–∏–∫–µ
                    const starType = Math.random();
                    if(starType < 0.7) {
                        colors[i3] = 0.8;      // R
                        colors[i3 + 1] = 0.8;  // G
                        colors[i3 + 2] = 1.0;  // B (–≥–æ–ª—É–±—ã–µ)
                    } else if(starType < 0.9) {
                        colors[i3] = 1.0;
                        colors[i3 + 1] = 0.9;
                        colors[i3 + 2] = 0.8;  // –∂–µ–ª—Ç—ã–µ
                    } else {
                        colors[i3] = 1.0;
                        colors[i3 + 1] = 0.8;
                        colors[i3 + 2] = 0.8;  // –∫—Ä–∞—Å–Ω—ã–µ
                    }
                }
                
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 1.5,
                    vertexColors: true,
                    transparent: true,
                    sizeAttenuation: true
                });
                
                const galaxy = new THREE.Points(geometry, material);
                galaxyGroup.add(galaxy);
                
                // –Ø–¥—Ä–æ –≥–∞–ª–∞–∫—Ç–∏–∫–∏
                const coreGeometry = new THREE.SphereGeometry(15, 32, 32);
                const coreMaterial = new THREE.MeshBasicMaterial({
                    color: 0x222266,
                    transparent: true,
                    opacity: 0.3
                });
                
                const core = new THREE.Mesh(coreGeometry, coreMaterial);
                galaxyGroup.add(core);
                
                galaxyGroup.scale.set(2, 2, 2);
                scene.add(galaxyGroup);
            }
        }
        
        function createStarField() {
            const starCount = CONFIG.particleCount;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(starCount * 3);
            const colors = new Float32Array(starCount * 3);
            const sizes = new Float32Array(starCount);
            
            for(let i = 0; i < starCount; i++) {
                const i3 = i * 3;
                
                // –°—Ñ–µ—Ä–∏—á–µ—Å–∫–æ–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ
                const radius = 800 + Math.random() * 1200;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                
                positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i3 + 1] = radius * Math.cos(phi);
                positions[i3 + 2] = radius * Math.sin(phi) * Math.sin(theta);
                
                // –†–µ–∞–ª–∏—Å—Ç–∏—á–Ω—ã–µ —Ü–≤–µ—Ç–∞ –∑–≤–µ–∑–¥ –ø–æ —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–µ
                const temperature = Math.random();
                if(temperature < 0.6) {
                    // –•–æ–ª–æ–¥–Ω—ã–µ –∑–≤–µ–∑–¥—ã (–≥–æ–ª—É–±—ã–µ)
                    colors[i3] = 0.7;
                    colors[i3 + 1] = 0.8;
                    colors[i3 + 2] = 1.0;
                } else if(temperature < 0.85) {
                    // –°—Ä–µ–¥–Ω–∏–µ –∑–≤–µ–∑–¥—ã (–∂–µ–ª—Ç–æ-–±–µ–ª—ã–µ)
                    colors[i3] = 1.0;
                    colors[i3 + 1] = 0.95;
                    colors[i3 + 2] = 0.9;
                } else if(temperature < 0.95) {
                    // –¢–µ–ø–ª—ã–µ –∑–≤–µ–∑–¥—ã (–æ—Ä–∞–Ω–∂–µ–≤—ã–µ)
                    colors[i3] = 1.0;
                    colors[i3 + 1] = 0.8;
                    colors[i3 + 2] = 0.6;
                } else {
                    // –ö—Ä–∞—Å–Ω—ã–µ –≥–∏–≥–∞–Ω—Ç—ã
                    colors[i3] = 1.0;
                    colors[i3 + 1] = 0.6;
                    colors[i3 + 2] = 0.4;
                }
                
                // –†–∞–∑–Ω—ã–µ —Ä–∞–∑–º–µ—Ä—ã
                sizes[i] = Math.random() * 2.5 + 0.5;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0.0 }
                },
                vertexShader: `
                    attribute float size;
                    attribute vec3 color;
                    varying vec3 vColor;
                    uniform float time;
                    
                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        
                        // –ú–µ—Ä—Ü–∞–Ω–∏–µ –∑–≤–µ–∑–¥
                        float flicker = sin(time * 3.0 + float(gl_VertexID) * 0.1) * 0.15 + 0.85;
                        
                        gl_PointSize = size * (300.0 / -mvPosition.z) * flicker;
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    
                    void main() {
                        float r = distance(gl_PointCoord, vec2(0.5, 0.5));
                        if(r > 0.5) discard;
                        
                        // –ü–ª–∞–≤–Ω—ã–µ –∫—Ä–∞—è –∑–≤–µ–∑–¥
                        float alpha = 1.0 - smoothstep(0.0, 0.5, r);
                        
                        // –Ø—Ä–∫–æ–µ —è–¥—Ä–æ –∑–≤–µ–∑–¥—ã
                        float core = 1.0 - smoothstep(0.0, 0.2, r);
                        vec3 finalColor = vColor * (1.0 + core * 0.5);
                        
                        gl_FragColor = vec4(finalColor, alpha);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending
            });
            
            starField = new THREE.Points(geometry, material);
            scene.add(starField);
        }
        
        function createJupiter() {
            console.log('ü™ê –°–æ–∑–¥–∞–Ω–∏–µ –≤—ã—Å–æ–∫–æ–¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –Æ–ø–∏—Ç–µ—Ä–∞...');
            
            // –û—á–µ–Ω—å –¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –≥–µ–æ–º–µ—Ç—Ä–∏—è
            const segments = CONFIG.highQuality ? 256 : 128;
            const geometry = new THREE.SphereGeometry(6, segments, segments);
            
            // –°–æ–∑–¥–∞–µ–º —Å–≤–µ—Ä—Ö–¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ç–µ–∫—Å—Ç—É—Ä—ã
            const texture = createUltraDetailedJupiterTexture();
            const bumpTexture = createUltraDetailedBumpMap();
            const specularTexture = createSpecularMap();
            
            // –°–ª–æ–∂–Ω—ã–π –º–∞—Ç–µ—Ä–∏–∞–ª —Å —Ñ–∏–∑–∏—á–µ—Å–∫–∏ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–º —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–æ–º
            const material = new THREE.MeshStandardMaterial({
                map: texture,
                bumpMap: bumpTexture,
                bumpScale: 0.05,
                roughnessMap: specularTexture,
                roughness: 0.7,
                metalness: 0.3,
                emissive: new THREE.Color(0x442200),
                emissiveIntensity: 0.1,
                envMapIntensity: 0.2
            });
            
            jupiter = new THREE.Mesh(geometry, material);
            jupiter.castShadow = true;
            jupiter.receiveShadow = true;
            jupiter.userData = { originalScale: new THREE.Vector3(1, 1, 1) };
            scene.add(jupiter);
            
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Å—ã–ª–∫—É –Ω–∞ –º–∞—Ç–µ—Ä–∏–∞–ª –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏
            jupiter.material.userData = { pulseIntensity: 0 };
        }
        
        function createUltraDetailedJupiterTexture() {
            const canvas = document.createElement('canvas');
            const size = CONFIG.highQuality ? 4096 : 2048;
            canvas.width = size * 2;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            // –ë–∞–∑–æ–≤—ã–π –≥—Ä–∞–¥–∏–µ–Ω—Ç —Å –ø–ª–∞–≤–Ω—ã–º–∏ –ø–µ—Ä–µ—Ö–æ–¥–∞–º–∏
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
            gradient.addColorStop(0.0, '#FFE5B4');   // –°–≤–µ—Ç–ª—ã–π –∫—Ä–µ–º–æ–≤—ã–π
            gradient.addColorStop(0.1, '#FFD8A8');   // –ü–µ—Ä—Å–∏–∫–æ–≤—ã–π
            gradient.addColorStop(0.25, '#FFB347');  // –û—Ä–∞–Ω–∂–µ–≤–æ-–∂–µ–ª—Ç—ã–π
            gradient.addColorStop(0.4, '#FF8C42');   // –¢–µ–ø–ª—ã–π –æ—Ä–∞–Ω–∂–µ–≤—ã–π
            gradient.addColorStop(0.55, '#E68A2E');  // –ì–ª—É–±–æ–∫–∏–π –æ—Ä–∞–Ω–∂–µ–≤—ã–π
            gradient.addColorStop(0.7, '#CC6E1D');   // –ö—Ä–∞—Å–Ω–æ-–æ—Ä–∞–Ω–∂–µ–≤—ã–π
            gradient.addColorStop(0.85, '#B35917');  // –ö–æ—Ä–∏—á–Ω–µ–≤–æ-–æ—Ä–∞–Ω–∂–µ–≤—ã–π
            gradient.addColorStop(1.0, '#994C13');   // –¢–µ–º–Ω–æ-–∫–æ—Ä–∏—á–Ω–µ–≤—ã–π
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // –°–æ–∑–¥–∞–µ–º —Å–ª–æ–∂–Ω—ã–µ –∞—Ç–º–æ—Å—Ñ–µ—Ä–Ω—ã–µ –ø–æ–ª–æ—Å—ã
            createAtmosphericBands(ctx, canvas);
            
            // –ë–æ–ª—å—à–æ–µ –ö—Ä–∞—Å–Ω–æ–µ –ü—è—Ç–Ω–æ —Å –¥–µ—Ç–∞–ª—è–º–∏
            createGreatRedSpot(ctx, canvas);
            
            // –ê—Ç–º–æ—Å—Ñ–µ—Ä–Ω—ã–µ –≤–∏—Ö—Ä–∏ –∏ —à—Ç–æ—Ä–º—ã
            createAtmosphericVortices(ctx, canvas);
            
            // –¢–µ–Ω–∏ –∏ –æ—Å–≤–µ—â–µ–Ω–∏–µ –¥–ª—è –æ–±—ä–µ–º–∞
            createVolumeShading(ctx, canvas);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.ClampToEdgeWrapping;
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            texture.encoding = THREE.sRGBEncoding;
            
            return texture;
        }
        
        function createAtmosphericBands(ctx, canvas) {
            const bands = [
                {y: canvas.height * 0.1, height: 45, color: '#E67E22', wave: 25, opacity: 0.9},
                {y: canvas.height * 0.2, height: 55, color: '#D35400', wave: 30, opacity: 0.95},
                {y: canvas.height * 0.3, height: 65, color: '#BA4A00', wave: 35, opacity: 0.9},
                {y: canvas.height * 0.4, height: 75, color: '#A04000', wave: 40, opacity: 0.85},
                {y: canvas.height * 0.5, height: 85, color: '#8B4000', wave: 45, opacity: 0.9},
                {y: canvas.height * 0.6, height: 75, color: '#7B3F00', wave: 40, opacity: 0.85},
                {y: canvas.height * 0.7, height: 65, color: '#6B3F00', wave: 35, opacity: 0.9},
                {y: canvas.height * 0.8, height: 55, color: '#5B3F00', wave: 30, opacity: 0.85}
            ];
            
            bands.forEach(band => {
                ctx.save();
                
                // –°–æ–∑–¥–∞–µ–º –≥—Ä–∞–¥–∏–µ–Ω—Ç –¥–ª—è –æ–±—ä–µ–º–∞ –ø–æ–ª–æ—Å—ã
                const bandGradient = ctx.createLinearGradient(0, band.y, 0, band.y + band.height);
                bandGradient.addColorStop(0, `${band.color}20`);
                bandGradient.addColorStop(0.2, `${band.color}80`);
                bandGradient.addColorStop(0.5, `${band.color}FF`);
                bandGradient.addColorStop(0.8, `${band.color}80`);
                bandGradient.addColorStop(1, `${band.color}20`);
                
                ctx.fillStyle = bandGradient;
                
                // –†–∏—Å—É–µ–º –≤–æ–ª–Ω–∏—Å—Ç—É—é –ø–æ–ª–æ—Å—É
                ctx.beginPath();
                const segments = 200;
                
                for(let i = 0; i <= segments; i++) {
                    const x = (i / segments) * canvas.width;
                    const wave = Math.sin(x * 0.02 + band.y * 0.01) * band.wave;
                    const y = band.y + wave + band.height * (i / segments);
                    
                    if(i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                for(let i = segments; i >= 0; i--) {
                    const x = (i / segments) * canvas.width;
                    const wave = Math.sin(x * 0.02 + band.y * 0.01) * band.wave;
                    const y = band.y + wave;
                    
                    ctx.lineTo(x, y);
                }
                
                ctx.closePath();
                ctx.globalAlpha = band.opacity;
                ctx.fill();
                
                // –î–æ–±–∞–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç—É—Ä—É –≤–Ω—É—Ç—Ä–∏ –ø–æ–ª–æ—Å—ã
                ctx.globalAlpha = 0.3;
                ctx.strokeStyle = band.color;
                ctx.lineWidth = 2;
                
                for(let i = 0; i < 20; i++) {
                    const lineY = band.y + (band.height * (i / 20)) + Math.random() * 10 - 5;
                    ctx.beginPath();
                    ctx.moveTo(0, lineY);
                    ctx.bezierCurveTo(
                        canvas.width * 0.3, lineY + Math.random() * 20 - 10,
                        canvas.width * 0.7, lineY + Math.random() * 20 - 10,
                        canvas.width, lineY
                    );
                    ctx.stroke();
                }
                
                ctx.restore();
            });
        }
        
        function createGreatRedSpot(ctx, canvas) {
            const centerX = canvas.width * 0.72;
            const centerY = canvas.height * 0.38;
            const width = 180;
            const height = 80;
            
            ctx.save();
            
            // –û—Å–Ω–æ–≤–Ω–æ–µ –ø—è—Ç–Ω–æ —Å –≥—Ä–∞–¥–∏–µ–Ω—Ç–æ–º
            ctx.beginPath();
            ctx.ellipse(centerX, centerY, width, height, Math.PI/6, 0, Math.PI * 2);
            
            const spotGradient = ctx.createRadialGradient(
                centerX, centerY, 0,
                centerX, centerY, width
            );
            spotGradient.addColorStop(0, '#8B0000');
            spotGradient.addColorStop(0.2, '#A52A2A');
            spotGradient.addColorStop(0.4, '#CD5C5C');
            spotGradient.addColorStop(0.6, '#DC143C');
            spotGradient.addColorStop(0.8, '#A52A2A');
            spotGradient.addColorStop(1, '#8B0000');
            
            ctx.fillStyle = spotGradient;
            ctx.fill();
            
            // –í–∏—Ö—Ä–µ–≤—ã–µ —É–∑–æ—Ä—ã –≤–Ω—É—Ç—Ä–∏ –ø—è—Ç–Ω–∞
            ctx.strokeStyle = '#FF4500';
            ctx.lineWidth = 4;
            ctx.globalAlpha = 0.7;
            
            for(let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const radius = width * 0.7;
                
                ctx.beginPath();
                ctx.arc(
                    centerX + Math.cos(angle) * radius * 0.6,
                    centerY + Math.sin(angle) * radius * 0.6,
                    radius * 0.25,
                    angle - Math.PI/3,
                    angle + Math.PI/3
                );
                ctx.stroke();
            }
            
            // –î–µ—Ç–∞–ª–∏ –ø–æ –∫—Ä–∞—è–º –ø—è—Ç–Ω–∞
            ctx.globalAlpha = 0.5;
            ctx.lineWidth = 6;
            ctx.strokeStyle = '#FF6347';
            ctx.beginPath();
            ctx.ellipse(centerX, centerY, width * 1.1, height * 1.1, Math.PI/6, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.restore();
        }
        
        function createAtmosphericVortices(ctx, canvas) {
            ctx.save();
            ctx.globalAlpha = 0.8;
            
            // –°–æ–∑–¥–∞–µ–º –º–Ω–æ–∂–µ—Å—Ç–≤–æ –º–µ–ª–∫–∏—Ö –≤–∏—Ö—Ä–µ–π
            for(let i = 0; i < 60; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const size = Math.random() * 60 + 20;
                
                // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –µ—Å–ª–∏ –ø–æ–ø–∞–¥–∞–µ—Ç –Ω–∞ –ë–æ–ª—å—à–æ–µ –ö—Ä–∞—Å–Ω–æ–µ –ü—è—Ç–Ω–æ
                const distToRedSpot = Math.sqrt(Math.pow(x - canvas.width * 0.72, 2) + 
                                               Math.pow(y - canvas.height * 0.38, 2));
                if(distToRedSpot < 200) continue;
                
                // –í—ã–±–∏—Ä–∞–µ–º —Ü–≤–µ—Ç –≤–∏—Ö—Ä—è
                const vortexColors = ['#FF6347', '#FF4500', '#FF8C00', '#DC143C'];
                const color = vortexColors[Math.floor(Math.random() * vortexColors.length)];
                
                // –†–∏—Å—É–µ–º –≤–∏—Ö—Ä—å
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                
                const vortexGradient = ctx.createRadialGradient(x, y, 0, x, y, size);
                vortexGradient.addColorStop(0, `${color}FF`);
                vortexGradient.addColorStop(0.5, `${color}80`);
                vortexGradient.addColorStop(1, `${color}00`);
                
                ctx.fillStyle = vortexGradient;
                ctx.fill();
                
                // –°–ø–∏—Ä–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏ –≤–Ω—É—Ç—Ä–∏ –≤–∏—Ö—Ä—è
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.6;
                
                for(let j = 0; j < 3; j++) {
                    ctx.beginPath();
                    for(let k = 0; k < size * 3; k += 3) {
                        const angle = k * 0.15 + j * Math.PI/3;
                        const radius = k * 0.3;
                        
                        const spiralX = x + Math.cos(angle) * radius;
                        const spiralY = y + Math.sin(angle) * radius;
                        
                        if(k === 0) {
                            ctx.moveTo(spiralX, spiralY);
                        } else {
                            ctx.lineTo(spiralX, spiralY);
                        }
                    }
                    ctx.stroke();
                }
            }
            
            ctx.restore();
        }
        
        function createVolumeShading(ctx, canvas) {
            // –î–æ–±–∞–≤–ª—è–µ–º —Ç–µ–Ω–∏ –¥–ª—è –æ–±—ä–µ–º–∞
            ctx.save();
            ctx.globalAlpha = 0.1;
            ctx.fillStyle = '#000000';
            
            // –õ–µ–≤–∞—è —Ç–µ–Ω—å (–Ω–æ—á–Ω–∞—è —Å—Ç–æ—Ä–æ–Ω–∞)
            const shadowGradient = ctx.createLinearGradient(0, 0, canvas.width * 0.3, 0);
            shadowGradient.addColorStop(0, '#000000');
            shadowGradient.addColorStop(1, '#00000000');
            
            ctx.fillStyle = shadowGradient;
            ctx.fillRect(0, 0, canvas.width * 0.3, canvas.height);
            
            // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –∫—Ä–∞–µ–≤
            ctx.globalAlpha = 0.05;
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.arc(canvas.width * 0.5, canvas.height * 0.5, canvas.height * 0.48, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.restore();
        }
        
        function createUltraDetailedBumpMap() {
            const canvas = document.createElement('canvas');
            canvas.width = 2048;
            canvas.height = 1024;
            const ctx = canvas.getContext('2d');
            
            // –ó–∞–ø–æ–ª–Ω—è–µ–º —Å–ª—É—á–∞–π–Ω—ã–º —à—É–º–æ–º
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const data = imageData.data;
            
            for(let i = 0; i < data.length; i += 4) {
                const value = Math.random() * 255;
                data[i] = value;      // R
                data[i + 1] = value;  // G
                data[i + 2] = value;  // B
                data[i + 3] = 255;    // A
            }
            
            ctx.putImageData(imageData, 0, 0);
            
            // –î–æ–±–∞–≤–ª—è–µ–º –∫—Ä—É–ø–Ω—ã–µ –∞—Ç–º–æ—Å—Ñ–µ—Ä–Ω—ã–µ –æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è
            for(let i = 0; i < 50; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = Math.random() * 80 + 20;
                
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                gradient.addColorStop(0, 'rgb(255, 255, 255)');
                gradient.addColorStop(0.3, 'rgb(192, 192, 192)');
                gradient.addColorStop(0.7, 'rgb(128, 128, 128)');
                gradient.addColorStop(1, 'rgb(0, 0, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // –î–æ–±–∞–≤–ª—è–µ–º –º–µ–ª–∫–∏–µ –¥–µ—Ç–∞–ª–∏
            for(let i = 0; i < 500; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = Math.random() * 15 + 5;
                const intensity = Math.random() * 128 + 127;
                
                ctx.fillStyle = `rgb(${intensity}, ${intensity}, ${intensity})`;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.ClampToEdgeWrapping;
            
            return texture;
        }
        
        function createSpecularMap() {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // –û–±–ª–∞—Å—Ç—å —Å –≤—ã—Å–æ–∫–æ–π –æ—Ç—Ä–∞–∂–∞—é—â–µ–π —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å—é (—ç–∫–≤–∞—Ç–æ—Ä)
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, 'rgb(100, 100, 100)');
            gradient.addColorStop(0.3, 'rgb(200, 200, 200)');
            gradient.addColorStop(0.5, 'rgb(255, 255, 255)');
            gradient.addColorStop(0.7, 'rgb(200, 200, 200)');
            gradient.addColorStop(1, 'rgb(100, 100, 100)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            return new THREE.CanvasTexture(canvas);
        }
        
        function createAtmosphere() {
            const geometry = new THREE.SphereGeometry(6.15, 128, 128);
            
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0.0 },
                    viewVector: { value: camera.position }
                },
                vertexShader: atmosphereVertexShader,
                fragmentShader: atmosphereFragmentShader,
                transparent: true,
                side: THREE.BackSide,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            atmosphere = new THREE.Mesh(geometry, material);
            scene.add(atmosphere);
        }
        
        function createClouds() {
            const geometry = new THREE.SphereGeometry(6.05, 192, 192);
            
            // –°–æ–∑–¥–∞–µ–º —Ç–µ–∫—Å—Ç—É—Ä—É –æ–±–ª–∞–∫–æ–≤
            const cloudTextureCanvas = document.createElement('canvas');
            cloudTextureCanvas.width = 512;
            cloudTextureCanvas.height = 256;
            const cloudCtx = cloudTextureCanvas.getContext('2d');
            
            // –†–∏—Å—É–µ–º –æ–±–ª–∞—á–Ω—É—é —Ç–µ–∫—Å—Ç—É—Ä—É
            for(let i = 0; i < 200; i++) {
                const x = Math.random() * cloudTextureCanvas.width;
                const y = Math.random() * cloudTextureCanvas.height;
                const w = Math.random() * 50 + 30;
                const h = Math.random() * 20 + 10;
                
                cloudCtx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.3 + 0.1})`;
                cloudCtx.beginPath();
                cloudCtx.ellipse(x, y, w, h, 0, 0, Math.PI * 2);
                cloudCtx.fill();
            }
            
            const cloudTexture = new THREE.CanvasTexture(cloudTextureCanvas);
            
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0.0 },
                    cloudTexture: { value: cloudTexture }
                },
                vertexShader: cloudVertexShader,
                fragmentShader: cloudFragmentShader,
                transparent: true,
                opacity: 0.2,
                side: THREE.DoubleSide,
                depthWrite: false
            });
            
            clouds = new THREE.Mesh(geometry, material);
            scene.add(clouds);
        }
        
        function createRings() {
            // –û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–ª—å—Ü–∞
            const ringGeometry = new THREE.RingGeometry(9, 13, 256);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFD8A8,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.08,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            rings = new THREE.Mesh(ringGeometry, ringMaterial);
            rings.rotation.x = Math.PI / 4;
            scene.add(rings);
            
            // –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ —Ç–æ–Ω–∫–∏–µ –∫–æ–ª—å—Ü–∞
            const innerRingGeometry = new THREE.RingGeometry(8, 9, 128);
            const innerRingMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFB347,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.04
            });
            
            const innerRings = new THREE.Mesh(innerRingGeometry, innerRingMaterial);
            innerRings.rotation.x = Math.PI / 4.1;
            scene.add(innerRings);
            
            // –í–Ω–µ—à–Ω–∏–µ —Ä–∞–∑—Ä–µ–∂–µ–Ω–Ω—ã–µ –∫–æ–ª—å—Ü–∞
            const outerRingGeometry = new THREE.RingGeometry(14, 16, 128);
            const outerRingMaterial = new THREE.MeshBasicMaterial({
                color: 0xFF9A3C,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.02
            });
            
            const outerRings = new THREE.Mesh(outerRingGeometry, outerRingMaterial);
            outerRings.rotation.x = Math.PI / 3.9;
            scene.add(outerRings);
        }
        
        function createAsteroidBelt() {
            const particleCount = 3000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            
            for(let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                
                // –ü–æ—è—Å –∞—Å—Ç–µ—Ä–æ–∏–¥–æ–≤ –≤ —Ñ–æ—Ä–º–µ —Ç–æ—Ä–∞
                const radius = 20 + Math.random() * 40;
                const angle = Math.random() * Math.PI * 2;
                const spread = (Math.random() - 0.5) * 10;
                
                positions[i3] = Math.cos(angle) * radius + spread;
                positions[i3 + 1] = (Math.random() - 0.5) * 8;
                positions[i3 + 2] = Math.sin(angle) * radius + spread;
                
                // –†–∞–∑–Ω—ã–µ —Ç–∏–ø—ã –∞—Å—Ç–µ—Ä–æ–∏–¥–æ–≤
                const asteroidType = Math.random();
                if(asteroidType < 0.4) {
                    // –õ–µ–¥—è–Ω—ã–µ
                    colors[i3] = 0.9;
                    colors[i3 + 1] = 0.95;
                    colors[i3 + 2] = 1.0;
                } else if(asteroidType < 0.7) {
                    // –ö–∞–º–µ–Ω–Ω—ã–µ
                    colors[i3] = 0.8;
                    colors[i3 + 1] = 0.7;
                    colors[i3 + 2] = 0.6;
                } else if(asteroidType < 0.9) {
                    // –ú–µ—Ç–∞–ª–ª–∏—á–µ—Å–∫–∏–µ
                    colors[i3] = 0.9;
                    colors[i3 + 1] = 0.9;
                    colors[i3 + 2] = 0.8;
                } else {
                    // –£–≥–ª–µ—Ä–æ–¥–∏—Å—Ç—ã–µ
                    colors[i3] = 0.3;
                    colors[i3 + 1] = 0.3;
                    colors[i3 + 2] = 0.3;
                }
                
                sizes[i] = Math.random() * 0.25 + 0.05;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0.0 }
                },
                vertexShader: `
                    attribute float size;
                    attribute vec3 color;
                    varying vec3 vColor;
                    uniform float time;
                    
                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        
                        // –í—Ä–∞—â–µ–Ω–∏–µ –∞—Å—Ç–µ—Ä–æ–∏–¥–æ–≤
                        float rotation = sin(time * 0.5 + float(gl_VertexID) * 0.01) * 0.1 + 1.0;
                        
                        gl_PointSize = size * (300.0 / -mvPosition.z) * rotation;
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    
                    void main() {
                        float r = distance(gl_PointCoord, vec2(0.5, 0.5));
                        if(r > 0.5) discard;
                        
                        float alpha = 1.0 - smoothstep(0.0, 0.5, r);
                        
                        // –ù–µ—Ä–æ–≤–Ω—ã–µ –∫—Ä–∞—è –∞—Å—Ç–µ—Ä–æ–∏–¥–æ–≤
                        float noise = fract(sin(dot(gl_PointCoord, vec2(12.9898, 78.233))) * 43758.5453);
                        alpha *= 0.8 + noise * 0.2;
                        
                        gl_FragColor = vec4(vColor, alpha * 0.9);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending
            });
            
            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }
        
        function createLighting() {
            // –û—Å–Ω–æ–≤–Ω–æ–π —Å–æ–ª–Ω–µ—á–Ω—ã–π —Å–≤–µ—Ç
            const sunLight = new THREE.DirectionalLight(0xFFFFFF, 2.0);
            sunLight.position.set(50, 30, 30);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 4096;
            sunLight.shadow.mapSize.height = 4096;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 500;
            sunLight.shadow.camera.left = -50;
            sunLight.shadow.camera.right = 50;
            sunLight.shadow.camera.top = 50;
            sunLight.shadow.camera.bottom = -50;
            scene.add(sunLight);
            
            // –ó–∞–ø–æ–ª–Ω—è—é—â–∏–π —Å–≤–µ—Ç
            const fillLight = new THREE.DirectionalLight(0xFFB347, 0.4);
            fillLight.position.set(-20, -10, -10);
            scene.add(fillLight);
            
            // –ö–æ–Ω—Ç—Ä–æ–≤–æ–π —Å–≤–µ—Ç
            const backLight = new THREE.DirectionalLight(0xFFD8A8, 0.2);
            backLight.position.set(-10, 5, -20);
            scene.add(backLight);
            
            // –†–∞—Å—Å–µ—è–Ω–Ω—ã–π —Å–≤–µ—Ç
            const ambientLight = new THREE.AmbientLight(0x333344, 0.1);
            scene.add(ambientLight);
            
            // –°–æ–∑–¥–∞–µ–º –≤–∏–¥–∏–º–æ–µ –°–æ–ª–Ω—Ü–µ
            const sunGeometry = new THREE.SphereGeometry(3, 32, 32);
            const sunMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFFF00,
                emissive: 0xFFFF00,
                emissiveIntensity: 2
            });
            
            const sun = new THREE.Mesh(sunGeometry, sunMaterial);
            sun.position.copy(sunLight.position);
            scene.add(sun);
        }
        
        // ============ –°–ò–°–¢–ï–ú–ê –°–ß–ï–¢–ß–ò–ö–ê –ò –í–ó–†–´–í–ê ============
        function handleTap(event) {
            if (isExploded) return;
            
            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∫–∞—Å–∞–Ω–∏—è
            const rect = renderer.domElement.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –ø–æ–ø–∞–ª–∏ –ª–∏ –ø–æ –Æ–ø–∏—Ç–µ—Ä—É
            const mouse = new THREE.Vector2();
            mouse.x = (x / rect.width) * 2 - 1;
            mouse.y = -(y / rect.height) * 2 + 1;
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            
            if (jupiter) {
                const intersects = raycaster.intersectObject(jupiter);
                
                if (intersects.length > 0) {
                    // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫
                    tapCount++;
                    document.getElementById('counter').textContent = tapCount;
                    
                    // –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä
                    const progress = (tapCount / CONFIG.tapCountForExplosion) * 100;
                    document.getElementById('progressBar').style.width = `${progress}%`;
                    
                    // –°–æ–∑–¥–∞–µ–º —ç—Ñ—Ñ–µ–∫—Ç –∫–ª–∏–∫–∞
                    createClickEffect(x, y);
                    
                    // –≠—Ñ—Ñ–µ–∫—Ç –ø—É–ª—å—Å–∞—Ü–∏–∏ –Æ–ø–∏—Ç–µ—Ä–∞
                    pulseJupiter();
                    
                    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å–µ–∫—Ä–µ—Ç–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø—Ä–∏ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–∏ –ø–æ—Ä–æ–≥–∞
                    if (tapCount === CONFIG.showSecretNotificationAt) {
                        showSecretNotification();
                    }
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –¥–æ—Å—Ç–∏–≥–ª–∏ –ª–∏ –ø–æ—Ä–æ–≥–∞ –≤–∑—Ä—ã–≤–∞
                    if (tapCount >= CONFIG.tapCountForExplosion) {
                        explodeJupiter();
                    }
                    
                    console.log(`–¢–∞–ø #${tapCount} –ø–æ –Æ–ø–∏—Ç–µ—Ä—É!`);
                }
            }
        }
        
        function createClickEffect(x, y) {
            const effect = document.createElement('div');
            effect.className = 'click-effect';
            effect.style.left = `${x}px`;
            effect.style.top = `${y}px`;
            document.body.appendChild(effect);
            
            clickEffects.push(effect);
            
            // –£–¥–∞–ª—è–µ–º —ç—Ñ—Ñ–µ–∫—Ç –ø–æ—Å–ª–µ –∞–Ω–∏–º–∞—Ü–∏–∏
            setTimeout(() => {
                if (effect.parentNode) {
                    effect.parentNode.removeChild(effect);
                    const index = clickEffects.indexOf(effect);
                    if (index > -1) clickEffects.splice(index, 1);
                }
            }, 800);
        }
        
        function pulseJupiter() {
            if (!jupiter) return;
            
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π –º–∞—Å—à—Ç–∞–± –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –ø—É–ª—å—Å–µ
            if (!jupiter.userData.originalScale) {
                jupiter.userData.originalScale = jupiter.scale.clone();
            }
            
            // –ê–Ω–∏–º–∞—Ü–∏—è –ø—É–ª—å—Å–∞—Ü–∏–∏
            const originalScale = jupiter.userData.originalScale;
            const pulseScale = 1.05;
            
            // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å –ø—É–ª—å—Å–∞—Ü–∏–∏
            jupiter.material.userData.pulseIntensity = 1.0;
            
            // –ê–Ω–∏–º–∞—Ü–∏—è –º–∞—Å—à—Ç–∞–±–∞
            const startScale = originalScale.clone();
            const targetScale = originalScale.clone().multiplyScalar(pulseScale);
            
            let progress = 0;
            const duration = 200; // –º—Å
            
            function animatePulse(timestamp) {
                if (!progress) progress = timestamp;
                const elapsed = timestamp - progress;
                const t = Math.min(elapsed / duration, 1);
                
                // –ö–≤–∞–¥—Ä–∞—Ç–∏—á–Ω–æ–µ easing
                const easeT = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
                
                if (t < 0.5) {
                    // –£–≤–µ–ª–∏—á–µ–Ω–∏–µ
                    const scale = startScale.clone().lerp(targetScale, easeT);
                    jupiter.scale.copy(scale);
                } else {
                    // –£–º–µ–Ω—å—à–µ–Ω–∏–µ
                    const scale = targetScale.clone().lerp(startScale, (easeT - 0.5) * 2);
                    jupiter.scale.copy(scale);
                }
                
                // –£–º–µ–Ω—å—à–∞–µ–º –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å –ø—É–ª—å—Å–∞—Ü–∏–∏ –º–∞—Ç–µ—Ä–∏–∞–ª–∞
                jupiter.material.userData.pulseIntensity = 1.0 - t;
                
                if (t < 1) {
                    requestAnimationFrame(animatePulse);
                } else {
                    jupiter.scale.copy(originalScale);
                    jupiter.material.userData.pulseIntensity = 0;
                }
            }
            
            requestAnimationFrame(animatePulse);
        }
        
        function showSecretNotification() {
            const notification = document.getElementById('secretNotification');
            const countElement = document.getElementById('secretCount');
            
            countElement.textContent = tapCount;
            notification.classList.add('visible');
            
            // –°–∫—Ä—ã–≤–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ —á–µ—Ä–µ–∑ 3 —Å–µ–∫—É–Ω–¥—ã
            setTimeout(() => {
                notification.classList.remove('visible');
            }, 3000);
        }
        
        function explodeJupiter() {
            if (isExploded) return;
            isExploded = true;
            
            console.log('üí• –í–ó–†–´–í –Æ–ü–ò–¢–ï–†–ê!');
            
            // –û—Ç–∫–ª—é—á–∞–µ–º –∞–≤—Ç–æ-–≤—Ä–∞—â–µ–Ω–∏–µ
            controls.autoRotate = false;
            
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —ç—Ñ—Ñ–µ–∫—Ç –≤–∑—Ä—ã–≤–∞
            document.getElementById('explosionOverlay').style.opacity = '1';
            document.getElementById('explosionText').classList.add('visible');
            
            // –°–æ–∑–¥–∞–µ–º —á–∞—Å—Ç–∏—Ü—ã –≤–∑—Ä—ã–≤–∞
            createExplosionParticles();
            
            // –°–æ–∑–¥–∞–µ–º —Å–µ—Ä–¥–µ—á–∫–∏
            createHeartParticles();
            
            // –£–¥–∞–ª—è–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π –Æ–ø–∏—Ç–µ—Ä
            setTimeout(() => {
                if (jupiter) scene.remove(jupiter);
                if (atmosphere) scene.remove(atmosphere);
                if (clouds) scene.remove(clouds);
                if (rings) scene.remove(rings);
                
                // –°–æ—Ç—Ä—è—Å–µ–Ω–∏–µ –∫–∞–º–µ—Ä—ã
                cameraShake();
            }, 500);
            
            // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —á–µ—Ä–µ–∑ 8 —Å–µ–∫—É–Ω–¥
            setTimeout(() => {
                resetJupiter();
            }, 8000);
        }
        
        function createExplosionParticles() {
            const particleCount = 1500;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const velocities = [];
            const rotations = [];
            
            for(let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                
                // –ù–∞—á–∞–ª—å–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è - –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—å –Æ–ø–∏—Ç–µ—Ä–∞
                const phi = Math.random() * Math.PI * 2;
                const theta = Math.random() * Math.PI;
                const radius = 6;
                
                positions[i3] = radius * Math.sin(theta) * Math.cos(phi);
                positions[i3 + 1] = radius * Math.cos(theta);
                positions[i3 + 2] = radius * Math.sin(theta) * Math.sin(phi);
                
                // –¶–≤–µ—Ç–∞ –≤–∑—Ä—ã–≤–∞ (–æ–≥–Ω–µ–Ω–Ω—ã–µ)
                const colorType = Math.random();
                if(colorType < 0.3) {
                    // –ö—Ä–∞—Å–Ω—ã–µ
                    colors[i3] = 1.0;
                    colors[i3 + 1] = 0.2 + Math.random() * 0.2;
                    colors[i3 + 2] = 0.2;
                } else if(colorType < 0.6) {
                    // –û—Ä–∞–Ω–∂–µ–≤—ã–µ
                    colors[i3] = 1.0;
                    colors[i3 + 1] = 0.5 + Math.random() * 0.2;
                    colors[i3 + 2] = 0.0;
                } else if(colorType < 0.8) {
                    // –ñ–µ–ª—Ç—ã–µ
                    colors[i3] = 1.0;
                    colors[i3 + 1] = 0.9 + Math.random() * 0.1;
                    colors[i3 + 2] = 0.3;
                } else {
                    // –ë–µ–ª—ã–µ (—Å–∞–º—ã–µ –≥–æ—Ä—è—á–∏–µ)
                    colors[i3] = 1.0;
                    colors[i3 + 1] = 1.0;
                    colors[i3 + 2] = 1.0;
                }
                
                // –°–ª—É—á–∞–π–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å –∏ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
                velocities.push({
                    x: (Math.random() - 0.5) * 0.4,
                    y: (Math.random() - 0.5) * 0.4,
                    z: (Math.random() - 0.5) * 0.4,
                    life: 100 + Math.random() * 100
                });
                
                // –°–ª—É—á–∞–π–Ω–æ–µ –≤—Ä–∞—â–µ–Ω–∏–µ
                rotations.push({
                    x: (Math.random() - 0.5) * 0.1,
                    y: (Math.random() - 0.5) * 0.1,
                    z: (Math.random() - 0.5) * 0.1
                });
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0.0 }
                },
                vertexShader: `
                    attribute vec3 color;
                    varying vec3 vColor;
                    uniform float time;
                    
                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        
                        // –≠—Ñ—Ñ–µ–∫—Ç —Å–≤–µ—á–µ–Ω–∏—è
                        float glow = sin(time * 5.0 + float(gl_VertexID) * 0.01) * 0.2 + 0.8;
                        
                        gl_PointSize = 4.0 * (300.0 / -mvPosition.z) * glow;
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    
                    void main() {
                        float r = distance(gl_PointCoord, vec2(0.5, 0.5));
                        if(r > 0.5) discard;
                        
                        float alpha = 1.0 - smoothstep(0.0, 0.5, r);
                        
                        // –Ø—Ä–∫–æ–µ —è–¥—Ä–æ —á–∞—Å—Ç–∏—Ü—ã
                        float core = 1.0 - smoothstep(0.0, 0.2, r);
                        vec3 finalColor = vColor * (1.0 + core);
                        
                        gl_FragColor = vec4(finalColor, alpha);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            const explosionParticleSystem = new THREE.Points(geometry, material);
            explosionParticleSystem.userData = { velocities, rotations, life: 200 };
            scene.add(explosionParticleSystem);
            explosionParticles.push(explosionParticleSystem);
        }
        
        function createHeartParticles() {
            const heartCount = 100;
            
            for(let i = 0; i < heartCount; i++) {
                setTimeout(() => {
                    const heart = document.createElement('div');
                    heart.className = 'heart-particle';
                    heart.innerHTML = '‚ù§Ô∏è';
                    heart.style.left = `${Math.random() * 100}vw`;
                    heart.style.top = `${Math.random() * 100}vh`;
                    heart.style.setProperty('--tx', `${(Math.random() - 0.5) * 300}px`);
                    heart.style.fontSize = `${Math.random() * 30 + 20}px`;
                    heart.style.opacity = '1';
                    
                    document.body.appendChild(heart);
                    heartParticles.push(heart);
                    
                    // –£–¥–∞–ª—è–µ–º —Å–µ—Ä–¥–µ—á–∫–æ –ø–æ—Å–ª–µ –∞–Ω–∏–º–∞—Ü–∏–∏
                    setTimeout(() => {
                        if (heart.parentNode) {
                            heart.parentNode.removeChild(heart);
                            const index = heartParticles.indexOf(heart);
                            if (index > -1) heartParticles.splice(index, 1);
                        }
                    }, 2000);
                }, i * 50); // –†–∞–∑–Ω–µ—Å–µ–º –ø–æ—è–≤–ª–µ–Ω–∏–µ —Å–µ—Ä–¥–µ—á–µ–∫ –≤–æ –≤—Ä–µ–º–µ–Ω–∏
            }
        }
        
        function cameraShake() {
            const originalPosition = camera.position.clone();
            const originalRotation = camera.rotation.clone();
            const shakeIntensity = 1.0;
            let shakeTime = 0;
            
            function shake(timestamp) {
                if (shakeTime < 2) { // 2 —Å–µ–∫—É–Ω–¥—ã —Ç—Ä—è—Å–∫–∏
                    shakeTime += 0.016; // –ü—Ä–∏–º–µ—Ä–Ω–æ 60 FPS
                    const progress = 1 - (shakeTime / 2);
                    const intensity = shakeIntensity * progress * progress;
                    
                    // –¢—Ä—è—Å–∫–∞ –ø–æ–∑–∏—Ü–∏–∏
                    camera.position.x = originalPosition.x + (Math.random() - 0.5) * intensity;
                    camera.position.y = originalPosition.y + (Math.random() - 0.5) * intensity;
                    camera.position.z = originalPosition.z + (Math.random() - 0.5) * intensity;
                    
                    // –¢—Ä—è—Å–∫–∞ –≤—Ä–∞—â–µ–Ω–∏—è
                    camera.rotation.x = originalRotation.x + (Math.random() - 0.5) * intensity * 0.1;
                    camera.rotation.y = originalRotation.y + (Math.random() - 0.5) * intensity * 0.1;
                    
                    requestAnimationFrame(shake);
                } else {
                    camera.position.copy(originalPosition);
                    camera.rotation.copy(originalRotation);
                }
            }
            
            shake();
        }
        
        function resetJupiter() {
            isExploded = false;
            tapCount = 0;
            
            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫ –∏ –ø—Ä–æ–≥—Ä–µ—Å—Å
            document.getElementById('counter').textContent = '0';
            document.getElementById('progressBar').style.width = '0%';
            
            // –°–∫—Ä—ã–≤–∞–µ–º —ç—Ñ—Ñ–µ–∫—Ç—ã –≤–∑—Ä—ã–≤–∞
            document.getElementById('explosionOverlay').style.opacity = '0';
            document.getElementById('explosionText').classList.remove('visible');
            
            // –£–¥–∞–ª—è–µ–º —á–∞—Å—Ç–∏—Ü—ã –≤–∑—Ä—ã–≤–∞
            explosionParticles.forEach(particleSystem => {
                scene.remove(particleSystem);
            });
            explosionParticles = [];
            
            // –í–∫–ª—é—á–∞–µ–º –∞–≤—Ç–æ-–≤—Ä–∞—â–µ–Ω–∏–µ
            controls.autoRotate = true;
            
            // –í–æ—Å—Å–æ–∑–¥–∞–µ–º –Æ–ø–∏—Ç–µ—Ä
            createJupiter();
            createAtmosphere();
            createClouds();
            createRings();
            
            console.log('üîÑ –Æ–ø–∏—Ç–µ—Ä –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω!');
        }
        
        // ============ –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –°–û–ë–´–¢–ò–ô ============
        function setupEventListeners() {
            let lastTapTime = 0;
            let tapTimeout;
            
            // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–ª–∏–∫–æ–≤/—Ç–∞–ø–æ–≤
            renderer.domElement.addEventListener('click', (e) => {
                const currentTime = new Date().getTime();
                const timeDiff = currentTime - lastTapTime;
                
                // –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –±—ã—Å—Ç—Ä—ã–µ –∫–ª–∏–∫–∏
                if (timeDiff < 300) {
                    clearTimeout(tapTimeout);
                    handleTap(e);
                } else {
                    tapTimeout = setTimeout(() => {
                        // –û–¥–∏–Ω–æ—á–Ω—ã–π —Ç–∞–ø
                        handleTap(e);
                    }, 300);
                }
                
                lastTapTime = currentTime;
            });
            
            // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–∞—Å–∞–Ω–∏–π –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤
            renderer.domElement.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const currentTime = new Date().getTime();
                const timeDiff = currentTime - lastTapTime;
                
                if (timeDiff < 300 && timeDiff > 0) {
                    clearTimeout(tapTimeout);
                    
                    // –°–æ–∑–¥–∞–µ–º –∏—Å–∫—É—Å—Å—Ç–≤–µ–Ω–Ω–æ–µ —Å–æ–±—ã—Ç–∏–µ –∫–ª–∏–∫–∞
                    const clickEvent = new MouseEvent('click', {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                    
                    handleTap(clickEvent);
                } else {
                    tapTimeout = setTimeout(() => {
                        const clickEvent = new MouseEvent('click', {
                            clientX: touch.clientX,
                            clientY: touch.clientY
                        });
                        
                        handleTap(clickEvent);
                    }, 300);
                }
                
                lastTapTime = currentTime;
            }, { passive: false });
            
            // –†–µ—Å–∞–π–∑ –æ–∫–Ω–∞
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            });
            
            // –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–µ –º–µ–Ω—é
            renderer.domElement.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });
            
            // –°–∫—Ä—ã—Ç–∏–µ –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä–∞ –ø—Ä–∏ –±–µ–∑–¥–µ–π—Å—Ç–≤–∏–∏
            let hideProgressTimeout;
            function resetHideProgressTimeout() {
                clearTimeout(hideProgressTimeout);
                document.getElementById('secretProgress').style.opacity = '0.1';
                
                hideProgressTimeout = setTimeout(() => {
                    if (!isExploded) {
                        document.getElementById('secretProgress').style.opacity = '0.05';
                    }
                }, 3000);
            }
            
            renderer.domElement.addEventListener('mousemove', resetHideProgressTimeout);
            renderer.domElement.addEventListener('touchstart', resetHideProgressTimeout);
            resetHideProgressTimeout();
        }
        
        // ============ –ê–ù–ò–ú–ê–¶–ò–Ø ============
        function animate() {
            requestAnimationFrame(animate);
            
            const time = clock.getElapsedTime();
            const delta = clock.getDelta();
            
            // –í—Ä–µ–º—è –¥–ª—è —à–µ–π–¥–µ—Ä–æ–≤
            if (atmosphere) atmosphere.material.uniforms.time.value = time;
            if (clouds) clouds.material.uniforms.time.value = time;
            if (starField) starField.material.uniforms.time.value = time;
            if (particles) particles.material.uniforms.time.value = time;
            
            // –ê–≤—Ç–æ-–≤—Ä–∞—â–µ–Ω–∏–µ –æ–±—ä–µ–∫—Ç–æ–≤
            if (jupiter && !isExploded) {
                jupiter.rotation.y += delta * CONFIG.rotationSpeed;
                
                // –≠—Ñ—Ñ–µ–∫—Ç –ø—É–ª—å—Å–∞—Ü–∏–∏ –ø—Ä–∏ –∫–ª–∏–∫–∞—Ö
                if (jupiter.material.userData.pulseIntensity > 0) {
                    const pulse = jupiter.material.userData.pulseIntensity;
                    jupiter.material.emissiveIntensity = 0.1 + pulse * 0.3;
                }
            }
            
            if (atmosphere && !isExploded) {
                atmosphere.rotation.y += delta * CONFIG.rotationSpeed * 1.2;
            }
            
            if (clouds && !isExploded) {
                clouds.rotation.y += delta * CONFIG.rotationSpeed * 1.5;
                clouds.rotation.x = Math.sin(time * 0.1) * 0.05;
            }
            
            if (rings && !isExploded) {
                rings.rotation.z += delta * 0.03;
            }
            
            if (particles && !isExploded) {
                particles.rotation.y += delta * 0.02;
            }
            
            if (starField) {
                starField.rotation.y += delta * 0.0003;
            }
            
            // –ê–Ω–∏–º–∞—Ü–∏—è —á–∞—Å—Ç–∏—Ü –≤–∑—Ä—ã–≤–∞
            explosionParticles.forEach((particleSystem, index) => {
                if (particleSystem.userData.life > 0) {
                    particleSystem.userData.life -= 1;
                    particleSystem.material.uniforms.time.value = time;
                    
                    const positions = particleSystem.geometry.attributes.position.array;
                    const velocities = particleSystem.userData.velocities;
                    
                    for(let i = 0; i < positions.length; i += 3) {
                        const particleIndex = i / 3;
                        const vel = velocities[particleIndex];
                        
                        if (vel.life > 0) {
                            vel.life -= 1;
                            
                            // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é
                            positions[i] += vel.x;
                            positions[i + 1] += vel.y;
                            positions[i + 2] += vel.z;
                            
                            // –ì—Ä–∞–≤–∏—Ç–∞—Ü–∏—è
                            vel.y -= 0.005;
                            
                            // –ó–∞–º–µ–¥–ª–µ–Ω–∏–µ
                            vel.x *= 0.99;
                            vel.y *= 0.99;
                            vel.z *= 0.99;
                            
                            // –≠—Ñ—Ñ–µ–∫—Ç –∏—Å—á–µ–∑–Ω–æ–≤–µ–Ω–∏—è
                            const lifeFactor = vel.life / 100;
                            positions[i] *= 0.99;
                            positions[i + 1] *= 0.99;
                            positions[i + 2] *= 0.99;
                        }
                    }
                    
                    particleSystem.geometry.attributes.position.needsUpdate = true;
                    
                    // –£–¥–∞–ª—è–µ–º —Å–∏—Å—Ç–µ–º—É —á–∞—Å—Ç–∏—Ü –∫–æ–≥–¥–∞ –∂–∏–∑–Ω—å –∑–∞–∫–æ–Ω—á–∏–ª–∞—Å—å
                    if (particleSystem.userData.life <= 0) {
                        scene.remove(particleSystem);
                        explosionParticles.splice(index, 1);
                    }
                }
            });
            
            // –î–≤–∏–∂–µ–Ω–∏–µ –°–æ–ª–Ω—Ü–∞
            const sunAngle = time * 0.02;
            const sunDistance = 50;
            scene.children.forEach(child => {
                if (child.isLight && child.position.length() > 40) {
                    child.position.x = Math.cos(sunAngle) * sunDistance;
                    child.position.z = Math.sin(sunAngle) * sunDistance;
                    
                    // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é –≤–∏–¥–∏–º–æ–≥–æ –°–æ–ª–Ω—Ü–∞
                    const sunMesh = scene.children.find(c => 
                        c.isMesh && c.position.distanceTo(child.position) < 5);
                    if (sunMesh) {
                        sunMesh.position.copy(child.position);
                    }
                }
            });
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
            controls.update();
            
            // –†–µ–Ω–¥–µ—Ä–∏–Ω–≥ —Å –ø–æ—Å—Ç–æ–±—Ä–∞–±–æ—Ç–∫–æ–π
            composer.render();
        }
        
        // ============ –ó–ê–ü–£–°–ö ============
        function checkWebGL() {
            try {
                const canvas = document.createElement('canvas');
                return !!(window.WebGLRenderingContext && 
                         (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
            } catch (e) {
                return false;
            }
        }
        
        if (checkWebGL()) {
            init();
        } else {
            document.getElementById('loading').innerHTML = `
                <div style="text-align: center; color: #ff4444; padding: 20px; max-width: 500px;">
                    <h2 style="margin-bottom: 20px;">‚ö†Ô∏è WebGL –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è</h2>
                    <p style="margin-bottom: 15px;">–í–∞—à –±—Ä–∞—É–∑–µ—Ä –∏–ª–∏ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç WebGL, –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–π –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è 3D –≥—Ä–∞—Ñ–∏–∫–∏.</p>
                    <p style="margin-bottom: 25px; color: rgba(255, 255, 255, 0.7);">–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–±–Ω–æ–≤–∏—Ç–µ –±—Ä–∞—É–∑–µ—Ä –∏–ª–∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –¥—Ä—É–≥–æ–π:</p>
                    <div style="text-align: left; color: rgba(255, 255, 255, 0.5); font-size: 14px;">
                        <div style="margin-bottom: 5px;">‚Ä¢ Google Chrome (—Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è)</div>
                        <div style="margin-bottom: 5px;">‚Ä¢ Mozilla Firefox</div>
                        <div style="margin-bottom: 5px;">‚Ä¢ Microsoft Edge</div>
                        <div>‚Ä¢ Safari (–ø–æ—Å–ª–µ–¥–Ω—è—è –≤–µ—Ä—Å–∏—è)</div>
                    </div>
                </div>
            `;
        }
        
        // –î–æ–±–∞–≤–ª—è–µ–º –ª–µ–≥–∫—É—é –≤–∏–±—Ä–∞—Ü–∏—é –Ω–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö –ø—Ä–∏ –∫–ª–∏–∫–∞—Ö
        function vibrateIfSupported() {
            if ('vibrate' in navigator) {
                navigator.vibrate(10);
            }
        }
        
        // –ú–æ–¥–∏—Ñ–∏—Ü–∏—Ä—É–µ–º handleTap –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –≤–∏–±—Ä–∞—Ü–∏–∏
        const originalHandleTap = handleTap;
        handleTap = function(e) {
            vibrateIfSupported();
            originalHandleTap(e);
        };
    </script>
</body>
</html>
